<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spikepulse - Simple Working Version</title>

    <style>
        /* Estilo noir cinematográfico mejorado */
        :root {
            --noir-white: #FFFFFF;
            --noir-light: #E0E0E0;
            --noir-medium: #808080;
            --noir-dark: #404040;
            --noir-black: #000000;
            --font-main: 'Courier New', monospace;

            /* Nuevos colores cinematográficos */
            --noir-deep-black: #0a0a0a;
            --noir-charcoal: #1a1a1a;
            --noir-steel: #2a2a2a;
            --noir-silver: #c0c0c0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-main);
            background:
                radial-gradient(ellipse at top, var(--noir-charcoal) 0%, var(--noir-deep-black) 50%, var(--noir-black) 100%),
                linear-gradient(135deg, var(--noir-black) 0%, var(--noir-charcoal) 25%, var(--noir-steel) 50%, var(--noir-charcoal) 75%, var(--noir-black) 100%);
            color: var(--noir-white);
            overflow: hidden;
            user-select: none;
            min-height: 100vh;
        }

        /* Fondo con grid cinematográfico más elegante */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 75% 75%, rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, transparent 98%, rgba(255, 255, 255, 0.05) 100%),
                linear-gradient(0deg, transparent 98%, rgba(255, 255, 255, 0.05) 100%);
            background-size: 80px 80px, 120px 120px, 60px 60px, 60px 60px;
            opacity: 0.6;
            z-index: -1;
            animation: gridFloat 20s linear infinite;
        }

        @keyframes gridFloat {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(-60px, -60px);
            }
        }

        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            background:
                radial-gradient(ellipse at center, rgba(26, 26, 26, 0.95) 0%, rgba(10, 10, 10, 0.98) 70%),
                linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(26, 26, 26, 0.9) 50%, rgba(0, 0, 0, 0.95) 100%);
            backdrop-filter: blur(10px);
        }

        .screen.hidden {
            display: none;
        }

        .title {
            font-size: 4rem;
            font-weight: bold;
            letter-spacing: 0.3em;
            margin-bottom: 1rem;
            color: var(--noir-white);
            text-shadow:
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 20px rgba(255, 255, 255, 0.5),
                0 0 30px rgba(255, 255, 255, 0.3),
                0 0 40px rgba(255, 255, 255, 0.1);
            animation: titleGlow 4s ease-in-out infinite;
        }

        @keyframes titleGlow {

            0%,
            100% {
                text-shadow:
                    0 0 10px rgba(255, 255, 255, 0.8),
                    0 0 20px rgba(255, 255, 255, 0.5),
                    0 0 30px rgba(255, 255, 255, 0.3);
            }

            50% {
                text-shadow:
                    0 0 15px rgba(255, 255, 255, 1),
                    0 0 30px rgba(255, 255, 255, 0.7),
                    0 0 45px rgba(255, 255, 255, 0.5),
                    0 0 60px rgba(255, 255, 255, 0.3);
            }
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--noir-silver);
            margin-bottom: 3rem;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
            letter-spacing: 0.1em;
            animation: subtitleFade 2s ease-out;
        }

        @keyframes subtitleFade {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }

            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .btn {
            background: linear-gradient(145deg,
                    rgba(64, 64, 64, 0.3) 0%,
                    rgba(26, 26, 26, 0.8) 50%,
                    rgba(0, 0, 0, 0.9) 100%);
            border: 2px solid var(--noir-silver);
            color: var(--noir-white);
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: bold;
            padding: 1rem 2.5rem;
            margin: 0.5rem 0;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            width: 250px;
            border-radius: 8px;
            box-shadow:
                0 4px 15px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .btn:hover {
            background: linear-gradient(145deg,
                    rgba(255, 255, 255, 0.9) 0%,
                    rgba(240, 240, 240, 0.95) 50%,
                    rgba(220, 220, 220, 1) 100%);
            color: var(--noir-black);
            border-color: var(--noir-white);
            box-shadow:
                0 6px 25px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(255, 255, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            text-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            transform: translateY(-3px) scale(1.02);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(-1px) scale(1.01);
        }

        .btn--primary {
            border-color: var(--noir-white);
            margin-bottom: 1.5rem;
            box-shadow:
                0 6px 20px rgba(0, 0, 0, 0.7),
                0 0 15px rgba(255, 255, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .game-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }

        .game-area.hidden {
            display: none;
        }

        canvas {
            border: 1px solid var(--noir-dark);
            background: var(--noir-black);
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--noir-light);
            z-index: 200;
        }

        .hud.hidden {
            display: none;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.2rem;
        }

        .hud-label {
            font-size: 0.6rem;
            color: var(--noir-medium);
            text-transform: uppercase;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 380px;
            /* Mover para no interferir con el minimapa más grande */
            display: flex;
            gap: 0.5rem;
            z-index: 200;
        }

        .controls.hidden {
            display: none;
        }

        .control-btn {
            background: transparent;
            border: 1px solid var(--noir-dark);
            color: var(--noir-medium);
            font-family: inherit;
            font-size: 0.6rem;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
        }

        .control-btn:hover {
            border-color: var(--noir-medium);
            color: var(--noir-white);
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6rem;
            color: var(--noir-medium);
            text-align: center;
            z-index: 200;
        }

        .instructions.hidden {
            display: none;
        }

        /* Minimapa */
        .minimap-container {
            position: fixed;
            top: 20px;
            right: 20px;
            /* Posición más accesible */
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.95), rgba(26, 26, 26, 0.9));
            border: 2px solid var(--noir-silver);
            border-radius: 12px;
            padding: 15px;
            z-index: 300;
            backdrop-filter: blur(10px);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .minimap-container.hidden {
            display: none;
        }

        .minimap-title {
            color: var(--noir-white);
            font-size: 0.7rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }

        #minimapCanvas {
            border: 1px solid var(--noir-dark);
            background: var(--noir-black);
            display: block;
        }
    </style>
</head>

<body>
    <!-- Pantalla de inicio -->
    <div id="startScreen" class="screen">
        <h1 class="title">SPIKEPULSE</h1>
        <p class="subtitle">Simple Working Version</p>

        <button id="startBtn" class="btn btn--primary">COMENZAR</button>
        <button id="recordsBtn" class="btn">RÉCORDS</button>
        <button id="configBtn" class="btn">CONFIG</button>
    </div>

    <!-- Pantalla de récords -->
    <div id="recordsScreen" class="screen hidden">
        <h2 class="title" style="font-size: 2rem;">RÉCORDS</h2>
        <div style="margin: 2rem 0;">
            <p style="margin: 1rem 0;">Mejor Distancia: <span id="bestDistance">0</span>m</p>
            <p style="margin: 1rem 0;">Partidas: <span id="gamesPlayed">0</span></p>
        </div>
        <button id="backFromRecords" class="btn">VOLVER</button>
    </div>

    <!-- Pantalla de configuración -->
    <div id="configScreen" class="screen hidden">
        <h2 class="title" style="font-size: 2rem;">CONFIG</h2>
        <div style="margin: 2rem 0;">
            <label style="display: block; margin: 1rem 0;">
                <input type="checkbox" id="showFPS" style="margin-right: 0.5rem;">
                Mostrar FPS
            </label>
            <label style="display: block; margin: 1rem 0;">
                <input type="checkbox" id="particles" checked style="margin-right: 0.5rem;">
                Partículas
            </label>
        </div>
        <button id="backFromConfig" class="btn">VOLVER</button>
    </div>

    <!-- Pantalla de Game Over -->
    <div id="gameOverScreen" class="screen hidden">
        <h2 class="title" style="font-size: 2rem;">GAME OVER</h2>
        <p class="subtitle">Distancia: <span id="finalDistance">0</span>m</p>
        <button id="restartBtn" class="btn btn--primary">REINTENTAR</button>
        <button id="menuBtn" class="btn">MENÚ</button>
    </div>

    <!-- Área de juego -->
    <div id="gameArea" class="game-area hidden">
        <canvas id="gameCanvas" width="1200" height="600"></canvas>
    </div>

    <!-- HUD -->
    <div id="gameHUD" class="hud hidden">
        <div class="hud-item">
            <div class="hud-label">Distancia</div>
            <div id="distanceDisplay">0m</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">Saltos</div>
            <div id="jumpsDisplay">2</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">Dash</div>
            <div id="dashDisplay">✓</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">Gravedad</div>
            <div id="gravityDisplay">↓</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Peligro</div>
            <div id="dangerLevel">●</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Dificultad</div>
            <div id="difficultyLevel">I</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Monedas</div>
            <div id="coinsDisplay">0</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Nivel</div>
            <div id="levelDisplay">1</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Progreso</div>
            <div id="progressDisplay">0%</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Posición</div>
            <div id="positionDisplay">0m</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Altura</div>
            <div id="altitudeDisplay">0m</div>
        </div>
    </div>

    <!-- Controles -->
    <div id="gameControls" class="controls hidden">
        <button id="pauseBtn" class="control-btn">PAUSA</button>
        <button id="fullscreenBtn" class="control-btn">⛶</button>
        <button id="minimapBtn" class="control-btn">MAPA</button>
    </div>

    <!-- Minimapa -->
    <div id="minimapContainer" class="minimap-container hidden">
        <div class="minimap-title">MINIMAPA</div>
        <canvas id="minimapCanvas" width="300" height="150"></canvas>
    </div>

    <!-- Instrucciones -->
    <div id="instructions" class="instructions hidden">
        ESPACIO: Saltar | A/D: Mover | W/S: Explorar Vertical | SHIFT: Dash | CTRL: Gravedad | ¡Evita obstáculos
        superiores! | CTRL+H: Hitboxes |
        CTRL+T: Tests
    </div>

    <script>
        console.log('🎮 Iniciando Spikepulse...');

        // Aplicar estilo noir básico
        document.body.style.background = 'radial-gradient(ellipse at top, #1a1a1a 0%, #0a0a0a 50%, #000000 100%)';

        // Mejorar título
        setTimeout(() => {
            const title = document.querySelector('.title');
            if (title) {
                title.style.color = '#ffffff';
                title.style.textShadow = '0 0 20px rgba(255,255,255,0.8)';
            }

            const subtitle = document.querySelector('.subtitle');
            if (subtitle) {
                subtitle.textContent = 'Noir Edition - Domina la Gravedad';
                subtitle.style.color = '#c0c0c0';
            }
        }, 100);

        // Estado del juego
        const game = {
            canvas: document.getElementById('gameCanvas'),
            ctx: null,
            running: false,
            paused: false,

            // Jugador
            player: {
                x: 100,
                y: 300,
                width: 30,
                height: 30,
                velY: 0,
                velX: 0,
                onGround: false,
                jumpsLeft: 2,
                dashAvailable: true,
                gravityInverted: false,
                // Hitbox del jugador (ligeramente más pequeña para mejor jugabilidad)
                hitbox: {
                    offsetX: 3,
                    offsetY: 3,
                    width: 24,
                    height: 24
                }
            },

            // Mundo expandido para exploración vertical y horizontal
            world: {
                gravity: 0.5,
                // Límites del mundo expandido
                bounds: {
                    left: 0,
                    right: 5000,  // Ancho total del mundo
                    top: -500,    // Permite explorar hacia arriba
                    bottom: 900   // Permite explorar hacia abajo
                },
                // Zonas de superficie (donde hay suelo/techo)
                surface: {
                    groundY: 370,     // Nivel del suelo principal
                    ceilingY: 30,     // Nivel del techo principal
                    thickness: 30     // Grosor del suelo/techo
                },
                speed: 0 // Sin movimiento automático - exploración libre
            },

            // Obstáculos
            obstacles: [],
            upperObstacles: [],

            // Monedas
            coins: [],

            // Configuración de nivel
            level: {
                current: 1,
                targetDistance: 500, // Distancia más larga para completar el nivel
                coinsInLevel: 0,
                totalCoinsInLevel: 50, // Más monedas totales en el nivel
                width: 2000, // Ancho total del nivel
                height: 400  // Alto del nivel
            },

            // Stats
            stats: {
                distance: 0,
                startTime: 0,
                coins: 0,
                totalCoins: parseInt(localStorage.getItem('totalCoins') || '0'),
                level: 1,
                levelProgress: 0
            },

            // Estado de colisión
            isColliding: false,
            gameOverSequence: {
                active: false,
                timer: 0,
                fadeAlpha: 0
            },

            // Input
            keys: {},

            // Config
            config: {
                showFPS: false,
                particles: true,
                showHitboxes: false
            },

            // Coordinador de obstáculos
            obstacleCoordinator: {
                lastPattern: null,
                patternStreak: 0,
                minSpacing: 150,
                maxSpacing: 300,
                difficultyLevel: 0,
                patternHistory: [],
                gravityAwareMode: true,
                lastGravityState: false,
                gravityChangeCount: 0
            },

            // Minimapa mejorado
            minimap: {
                width: 300,
                height: 150,
                scale: 0.06, // Escala más pequeña para mostrar más área
                offsetX: 0, // Desplazamiento horizontal
                offsetY: 0, // Desplazamiento vertical para exploración vertical
                visible: true,
                showVertical: true // Mostrar exploración vertical
            },

            // Cámara para exploración libre
            camera: {
                x: 0,
                y: 0,
                followPlayer: true,
                smoothing: 0.15 // Suavizado del seguimiento más responsivo
            }
        };

        // Inicialización
        function init() {
            game.canvas = document.getElementById('gameCanvas');
            game.ctx = game.canvas.getContext('2d');

            console.log('🎮 Inicializando juego...');
            console.log('Canvas:', game.canvas);
            console.log('Context:', game.ctx);

            // Event listeners
            setupEventListeners();

            console.log('✅ Juego inicializado correctamente');
        }

        function setupEventListeners() {
            // Botones de navegación
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('recordsBtn').addEventListener('click', () => showScreen('recordsScreen'));
            document.getElementById('configBtn').addEventListener('click', () => showScreen('configScreen'));
            document.getElementById('backFromRecords').addEventListener('click', () => showScreen('startScreen'));
            document.getElementById('backFromConfig').addEventListener('click', () => showScreen('startScreen'));
            document.getElementById('restartBtn').addEventListener('click', startGame);
            document.getElementById('menuBtn').addEventListener('click', () => showScreen('startScreen'));

            // Controles del juego
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

            // Teclado
            document.addEventListener('keydown', (e) => {
                game.keys[e.code] = true;

                // Controles específicos
                if (e.code === 'Space' && game.running) {
                    e.preventDefault();
                    jump();
                }
                if (e.code === 'ShiftLeft' && game.running) {
                    dash();
                }
                if (e.code === 'ControlLeft' && game.running) {
                    toggleGravity();
                }
                if (e.code === 'Escape') {
                    if (game.running) togglePause();
                }

                // Debug: mostrar/ocultar hitboxes
                if (e.code === 'KeyH' && e.ctrlKey) {
                    game.config.showHitboxes = !game.config.showHitboxes;
                    console.log('Hitboxes de debug:', game.config.showHitboxes ? 'activadas' : 'desactivadas');
                }

                // Debug: ejecutar tests de colisiones
                if (e.code === 'KeyT' && e.ctrlKey) {
                    testCollisionSystem();
                }
            });

            document.addEventListener('keyup', (e) => {
                game.keys[e.code] = false;
            });

            // Click para saltar
            game.canvas.addEventListener('click', () => {
                if (game.running) jump();
            });

            // Botón del minimapa
            document.getElementById('minimapBtn').addEventListener('click', toggleMinimap);
        }

        function showScreen(screenId) {
            // Ocultar todas las pantallas
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.add('hidden');
            });

            // Ocultar elementos del juego
            document.getElementById('gameArea').classList.add('hidden');
            document.getElementById('gameHUD').classList.add('hidden');
            document.getElementById('gameControls').classList.add('hidden');
            document.getElementById('instructions').classList.add('hidden');

            // Mostrar pantalla solicitada
            document.getElementById(screenId).classList.remove('hidden');

            // Parar el juego si está corriendo
            if (game.running) {
                game.running = false;
            }
        }

        function startGame() {
            console.log('🎮 Iniciando juego...');
            console.log('Estado antes de resetear:', {
                running: game.running,
                paused: game.paused,
                isColliding: game.isColliding,
                gameOverSequence: game.gameOverSequence.active
            });

            // Ocultar pantallas
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.add('hidden');
            });

            // Mostrar elementos del juego
            document.getElementById('gameArea').classList.remove('hidden');
            document.getElementById('gameHUD').classList.remove('hidden');
            document.getElementById('gameControls').classList.remove('hidden');
            document.getElementById('instructions').classList.remove('hidden');

            // Mostrar minimapa
            if (game.minimap.visible) {
                document.getElementById('minimapContainer').classList.remove('hidden');
            }

            // Resetear juego
            resetGame();

            // Iniciar loop
            game.running = true;
            game.paused = false;
            game.stats.startTime = Date.now();

            console.log('Estado después de resetear:', {
                running: game.running,
                paused: game.paused,
                isColliding: game.isColliding,
                gameOverSequence: game.gameOverSequence.active
            });

            gameLoop();
            console.log('🎮 Juego iniciado correctamente');
        }

        function resetGame() {
            // Resetear jugador
            game.player.x = 100;
            game.player.y = 200; // Posición más centrada entre suelo y techo
            game.player.velY = 0;
            game.player.velX = 0;
            game.player.onGround = false;
            game.player.jumpsLeft = 2;
            game.player.dashAvailable = true;
            game.player.gravityInverted = false;

            // Resetear obstáculos y monedas
            game.obstacles = [];
            game.upperObstacles = [];
            game.coins = [];

            // Resetear nivel
            game.level.current = 1;
            game.level.targetDistance = 500;
            game.level.coinsInLevel = 0;
            game.level.totalCoinsInLevel = 50;
            game.level.width = 5000; // Nivel mucho más amplio para exploración

            // Resetear cámara
            game.camera.x = 0;
            game.camera.y = 0;

            // Resetear stats
            game.stats.distance = 0;
            game.stats.coins = 0;
            game.stats.levelProgress = 0;

            // Resetear coordinador de obstáculos
            game.obstacleCoordinator.lastPattern = null;
            game.obstacleCoordinator.patternStreak = 0;
            game.obstacleCoordinator.difficultyLevel = 0;
            game.obstacleCoordinator.patternHistory = [];
            game.obstacleCoordinator.lastGravityState = false;
            game.obstacleCoordinator.gravityChangeCount = 0;

            // Resetear estado de colisión
            game.isColliding = false;
            game.gameOverSequence.active = false;
            game.gameOverSequence.timer = 0;
            game.gameOverSequence.fadeAlpha = 0;
            game.collisionEffect = null;
            game.gravityEffect = null;

            // Generar contenido inicial del nivel
            generateInitialLevelContent();
        }

        function gameLoop() {
            if (!game.running) return;

            // Siempre actualizar si hay secuencia de game over activa
            if (game.gameOverSequence.active) {
                updateGameOverSequence();
            } else if (!game.paused) {
                update();
            }

            render();

            requestAnimationFrame(gameLoop);
        }

        function update() {
            // Actualizar jugador
            updatePlayer();

            // Actualizar obstáculos
            updateObstacles();

            // Actualizar monedas
            updateCoins();

            // Actualizar cámara
            updateCamera();

            // Actualizar stats (ahora basado en la posición del jugador)
            game.stats.distance = Math.max(game.stats.distance, game.player.x * 0.1);

            // Verificar progreso del nivel
            checkLevelProgress();

            // Balanceador dinámico de dificultad
            balanceDifficulty();

            // Actualizar HUD
            updateHUD();

            // Verificar colisiones
            checkCollisions();

            // Verificar recolección de monedas
            checkCoinCollection();
        }

        function updateCamera() {
            if (game.camera.followPlayer) {
                // Seguir al jugador suavemente
                const targetX = game.player.x - game.canvas.width / 2;
                const targetY = game.player.y - game.canvas.height / 2;

                // Aplicar suavizado más responsivo
                const smoothing = 0.15; // Más responsivo que antes
                game.camera.x += (targetX - game.camera.x) * smoothing;
                game.camera.y += (targetY - game.camera.y) * smoothing;

                // Limitar la cámara a los bordes del mundo expandido
                const bounds = game.world.bounds;
                game.camera.x = Math.max(bounds.left, Math.min(bounds.right - game.canvas.width, game.camera.x));
                game.camera.y = Math.max(bounds.top, Math.min(bounds.bottom - game.canvas.height, game.camera.y));
            }
        }

        function updateCoins() {
            // Las monedas ya no se mueven automáticamente - están fijas en el mundo
            // Solo remover monedas que estén muy lejos del jugador para optimización
            game.coins = game.coins.filter(coin => {
                const distance = Math.abs(coin.x - game.player.x);
                return distance < game.canvas.width * 2; // Mantener monedas en un rango amplio
            });
        }

        function checkCoinCollection() {
            const player = game.player;

            game.coins.forEach(coin => {
                if (!coin.collected && checkPreciseCollision(player, coin)) {
                    // Recolectar moneda
                    coin.collected = true;
                    game.stats.coins += coin.value;
                    game.stats.totalCoins += coin.value;

                    // Guardar monedas totales
                    localStorage.setItem('totalCoins', game.stats.totalCoins.toString());

                    // Efecto visual de recolección
                    showCoinCollectionEffect(coin.x + coin.width / 2, coin.y + coin.height / 2);

                    console.log(`💰 Moneda recolectada! Total: ${game.stats.coins}`);
                }
            });
        }

        function checkLevelProgress() {
            // Progreso basado en la exploración del nivel (posición máxima alcanzada)
            const maxDistance = game.level.width * 0.1; // Convertir a metros
            const progress = (game.stats.distance / maxDistance) * 100;
            game.stats.levelProgress = Math.min(progress, 100);

            // Verificar si se completó el nivel (alcanzar el 80% del nivel)
            if (game.stats.distance >= maxDistance * 0.8) {
                completeLevel();
            }
        }

        function completeLevel() {
            console.log(`🎉 ¡Nivel ${game.level.current} completado!`);

            // Bonus por monedas recolectadas
            const coinBonus = game.stats.coins * 10;
            game.stats.totalCoins += coinBonus;
            localStorage.setItem('totalCoins', game.stats.totalCoins.toString());

            // Avanzar al siguiente nivel
            game.level.current++;
            game.level.targetDistance += 200; // Aumentar dificultad significativamente
            game.level.totalCoinsInLevel += 15; // Muchas más monedas en niveles superiores
            game.level.width += 500; // Hacer el nivel más ancho
            game.level.coinsInLevel = 0;

            // Resetear para el siguiente nivel
            game.stats.distance = 0;
            game.stats.coins = 0;
            game.obstacles = [];
            game.upperObstacles = [];
            game.coins = [];

            // Resetear posición del jugador y cámara
            game.player.x = 100;
            game.player.y = 200;
            game.camera.x = 0;
            game.camera.y = 0;

            // Generar contenido inicial del nuevo nivel
            generateInitialLevelContent();

            // Mostrar mensaje de nivel completado
            showLevelCompleteMessage(coinBonus);
        }

        function showCoinCollectionEffect(x, y) {
            // Efecto visual simple para recolección de monedas
            const effect = {
                x: x,
                y: y,
                particles: [],
                duration: 30
            };

            // Crear partículas doradas
            for (let i = 0; i < 8; i++) {
                effect.particles.push({
                    x: x,
                    y: y,
                    velX: (Math.random() - 0.5) * 8,
                    velY: (Math.random() - 0.5) * 8,
                    life: 30,
                    size: 2 + Math.random() * 2
                });
            }

            game.coinEffect = effect;
        }

        function generateVerticalCoins() {
            // Monedas en zonas superiores (requieren saltos múltiples o gravedad invertida)
            const upperChallengeAreas = [
                // Cerca de plataformas superiores
                { x: 580, y: -120 }, { x: 620, y: -140 }, { x: 660, y: -100 },
                { x: 1080, y: -220 }, { x: 1120, y: -240 }, { x: 1160, y: -200 }, { x: 1200, y: -180 },
                { x: 1880, y: -170 }, { x: 1920, y: -190 },
                { x: 2580, y: -320 }, { x: 2620, y: -340 }, { x: 2660, y: -300 }, { x: 2700, y: -280 },
                { x: 3280, y: -120 }, { x: 3320, y: -140 },
                { x: 4080, y: -270 }, { x: 4120, y: -290 }, { x: 4160, y: -250 },

                // Monedas en el aire (requieren dash + salto)
                { x: 750, y: -50 }, { x: 1350, y: -80 }, { x: 2000, y: -60 },
                { x: 2800, y: -100 }, { x: 3500, y: -70 }, { x: 4300, y: -90 },

                // Monedas muy altas (máximo desafío)
                { x: 1000, y: -350 }, { x: 2500, y: -400 }, { x: 4000, y: -380 }
            ];

            // Monedas en zonas inferiores (requieren exploración subterránea)
            const lowerChallengeAreas = [
                // Cerca de plataformas inferiores
                { x: 880, y: 620 }, { x: 920, y: 640 }, { x: 960, y: 600 },
                { x: 1580, y: 720 }, { x: 1620, y: 740 }, { x: 1660, y: 700 },
                { x: 2280, y: 670 }, { x: 2320, y: 690 }, { x: 2360, y: 650 },
                { x: 3080, y: 770 }, { x: 3120, y: 790 }, { x: 3160, y: 750 },
                { x: 3880, y: 700 }, { x: 3920, y: 720 }, { x: 3960, y: 680 },
                { x: 4580, y: 740 }, { x: 4620, y: 760 }, { x: 4660, y: 720 },

                // Monedas en pozos profundos
                { x: 1200, y: 800 }, { x: 1800, y: 820 }, { x: 2600, y: 840 },
                { x: 3400, y: 810 }, { x: 4200, y: 830 },

                // Monedas muy profundas (máximo desafío subterráneo)
                { x: 1500, y: 850 }, { x: 2500, y: 870 }, { x: 3500, y: 860 }
            ];

            // Monedas en ubicaciones especiales (requieren técnicas avanzadas)
            const specialChallengeAreas = [
                // Entre obstáculos (requieren timing perfecto)
                { x: 400, y: 200 }, { x: 800, y: 180 }, { x: 1200, y: 220 },
                { x: 1600, y: 160 }, { x: 2000, y: 240 }, { x: 2400, y: 200 },
                { x: 2800, y: 180 }, { x: 3200, y: 220 }, { x: 3600, y: 160 },
                { x: 4000, y: 240 }, { x: 4400, y: 200 }, { x: 4800, y: 180 },

                // Monedas que requieren cambio de gravedad
                { x: 600, y: 50 }, { x: 1000, y: 60 }, { x: 1400, y: 40 },
                { x: 1800, y: 70 }, { x: 2200, y: 50 }, { x: 2600, y: 60 },
                { x: 3000, y: 40 }, { x: 3400, y: 70 }, { x: 3800, y: 50 },
                { x: 4200, y: 60 }, { x: 4600, y: 40 }
            ];

            // Crear monedas en áreas superiores
            upperChallengeAreas.forEach(area => {
                createCoin(area.x, area.y);
            });

            // Crear monedas en áreas inferiores
            lowerChallengeAreas.forEach(area => {
                createCoin(area.x, area.y);
            });

            // Crear monedas especiales
            specialChallengeAreas.forEach(area => {
                createCoin(area.x, area.y);
            });
        }

        function generateInitialLevelContent() {
            console.log(`🏗️ Generando contenido para nivel ${game.level.current}...`);

            // Generar obstáculos distribuidos por todo el nivel
            for (let x = 300; x < game.level.width; x += 150 + Math.random() * 300) {
                createObstacleSet(x);
            }

            // Generar monedas adicionales distribuidas por el nivel
            const coinsToGenerate = Math.max(0, game.level.totalCoinsInLevel - game.level.coinsInLevel);
            for (let i = 0; i < coinsToGenerate; i++) {
                const x = 200 + Math.random() * (game.level.width - 400);
                createCoin(x);
            }

            // Generar monedas adicionales distribuidas uniformemente
            for (let x = 500; x < game.level.width - 200; x += 200 + Math.random() * 100) {
                if (Math.random() < 0.7) { // 70% de probabilidad de generar moneda
                    createCoin(x);
                }
            }

            // Generar monedas en áreas verticales para incentivar exploración
            generateVerticalCoins();

            console.log(`✅ Nivel generado: ${game.obstacles.length + game.upperObstacles.length} obstáculos, ${game.coins.length} monedas`);
        }

        function showLevelCompleteMessage(bonus) {
            // Crear mensaje temporal
            const message = document.createElement('div');
            message.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(145deg, rgba(255,215,0,0.9), rgba(255,165,0,0.8));
                color: black;
                padding: 20px 30px;
                border-radius: 12px;
                font-family: 'Courier New', monospace;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 1000;
                box-shadow: 0 8px 25px rgba(0,0,0,0.8);
                border: 2px solid #FFD700;
            `;
            message.innerHTML = `
                <div>🎉 ¡NIVEL ${game.level.current - 1} COMPLETADO! 🎉</div>
                <div style="font-size: 14px; margin-top: 10px;">
                    Bonus por monedas: +${bonus} monedas
                </div>
                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">
                    Iniciando Nivel ${game.level.current}...
                </div>
            `;
            document.body.appendChild(message);

            // Remover mensaje después de 3 segundos
            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
            }, 3000);
        }

        // Actualizar secuencia de game over
        function updateGameOverSequence() {
            const sequence = game.gameOverSequence;
            sequence.timer++;

            // Fase 1: Mostrar partículas (primeros 60 frames = 1 segundo)
            if (sequence.timer <= 60) {
                // Solo actualizar efectos visuales, no hacer nada más
                return;
            }

            // Fase 2: Fadeout (siguientes 30 frames = 0.5 segundos)
            if (sequence.timer <= 90) {
                sequence.fadeAlpha = (sequence.timer - 60) / 30;
                return;
            }

            // Fase 3: Ir a pantalla de game over
            console.log('🎬 Finalizando secuencia, yendo a game over');
            gameOver();
        }

        function checkSurfaceCollision(player) {
            const surface = game.world.surface;

            if (!player.gravityInverted) {
                // Gravedad normal: verificar colisión con el suelo
                if (player.y + player.height >= surface.groundY &&
                    player.y + player.height <= surface.groundY + surface.thickness &&
                    player.velY >= 0) {
                    player.y = surface.groundY - player.height;
                    player.velY = 0;
                    return true;
                }

                // Verificar colisión con el techo desde abajo
                if (player.y <= surface.ceilingY + surface.thickness &&
                    player.y >= surface.ceilingY &&
                    player.velY <= 0) {
                    player.y = surface.ceilingY + surface.thickness;
                    player.velY = 0;
                    return false; // No está "en el suelo" cuando golpea el techo
                }
            } else {
                // Gravedad invertida: verificar colisión con el techo
                if (player.y <= surface.ceilingY + surface.thickness &&
                    player.y >= surface.ceilingY &&
                    player.velY <= 0) {
                    player.y = surface.ceilingY + surface.thickness;
                    player.velY = 0;
                    return true;
                }

                // Verificar colisión con el suelo desde arriba
                if (player.y + player.height >= surface.groundY &&
                    player.y + player.height <= surface.groundY + surface.thickness &&
                    player.velY >= 0) {
                    player.y = surface.groundY - player.height;
                    player.velY = 0;
                    return false; // No está "en el suelo" cuando golpea desde arriba
                }
            }

            return false;
        }

        function updatePlayer() {
            const player = game.player;

            // Movimiento horizontal
            if (game.keys['KeyA'] || game.keys['ArrowLeft']) {
                player.velX = Math.max(player.velX - 0.5, -5);
            } else if (game.keys['KeyD'] || game.keys['ArrowRight']) {
                player.velX = Math.min(player.velX + 0.5, 5);
            } else {
                player.velX *= 0.8; // Fricción
            }

            // Movimiento vertical para exploración (W/S)
            if (game.keys['KeyW'] || game.keys['ArrowUp']) {
                player.velY = Math.max(player.velY - 0.3, -3); // Impulso hacia arriba
            } else if (game.keys['KeyS'] || game.keys['ArrowDown']) {
                player.velY = Math.min(player.velY + 0.3, 3); // Impulso hacia abajo
            }

            // Gravedad
            const gravity = player.gravityInverted ? -game.world.gravity : game.world.gravity;
            player.velY += gravity;

            // Aplicar velocidad
            player.x += player.velX;
            player.y += player.velY;

            // Límites del mundo expandido
            if (player.x < game.world.bounds.left) player.x = game.world.bounds.left;
            if (player.x > game.world.bounds.right - player.width) {
                player.x = game.world.bounds.right - player.width;
            }
            if (player.y < game.world.bounds.top) player.y = game.world.bounds.top;
            if (player.y > game.world.bounds.bottom - player.height) {
                player.y = game.world.bounds.bottom - player.height;
            }

            // Colisión con superficies principales (suelo y techo)
            const onMainSurface = checkSurfaceCollision(player);

            if (onMainSurface) {
                player.onGround = true;
                player.jumpsLeft = 2;
                player.dashAvailable = true;
            } else {
                player.onGround = false;
            }
        }

        function updateObstacles() {
            // Los obstáculos ya no se mueven - están fijos en el mundo
            // Solo optimizar removiendo obstáculos muy lejanos del jugador
            const playerX = game.player.x;
            const maxDistance = game.canvas.width * 3;

            game.obstacles = game.obstacles.filter(obstacle => {
                const distance = Math.abs(obstacle.x - playerX);
                return distance < maxDistance;
            });

            game.upperObstacles = game.upperObstacles.filter(obstacle => {
                const distance = Math.abs(obstacle.x - playerX);
                return distance < maxDistance;
            });

            // Generar más contenido si el jugador se acerca al final del nivel generado
            const lastObstacle = game.obstacles[game.obstacles.length - 1];
            const lastUpperObstacle = game.upperObstacles[game.upperObstacles.length - 1];
            const lastX = Math.max(
                lastObstacle ? lastObstacle.x : 0,
                lastUpperObstacle ? lastUpperObstacle.x : 0
            );

            // Si el jugador está cerca del final del contenido generado, generar más
            if (playerX > lastX - game.canvas.width * 2) {
                const dynamicSpacing = calculateDynamicSpacing();
                createObstacleSet(lastX + dynamicSpacing);
            }
        }

        function createObstacle(x) {
            const height = 40 + Math.random() * 60;
            const obstacle = {
                x: x,
                y: game.world.surface.groundY - height,
                width: 20,
                height: height,
                type: 'ground',
                // Hitbox más precisa (ligeramente más pequeña que el visual)
                hitbox: {
                    offsetX: 2,
                    offsetY: 2,
                    width: 16,
                    height: height - 4
                }
            };
            game.obstacles.push(obstacle);
        }

        function createUpperObstacle(x) {
            const height = 40 + Math.random() * 80;
            const obstacle = {
                x: x,
                y: game.world.surface.ceilingY + game.world.surface.thickness,
                width: 20,
                height: height,
                type: 'ceiling',
                // Hitbox más precisa para obstáculos colgantes
                hitbox: {
                    offsetX: 2,
                    offsetY: 0,
                    width: 16,
                    height: height - 2
                }
            };
            game.upperObstacles.push(obstacle);
        }

        function createCoin(x, y) {
            const coin = {
                x: x,
                y: y || (game.world.surface.ceilingY + 80 + Math.random() * (game.world.surface.groundY - game.world.surface.ceilingY - 160)),
                width: 16,
                height: 16,
                collected: false,
                value: 1,
                animationOffset: Math.random() * Math.PI * 2, // Para animación
                // Hitbox para recolección
                hitbox: {
                    offsetX: 2,
                    offsetY: 2,
                    width: 12,
                    height: 12
                }
            };
            game.coins.push(coin);
            game.level.coinsInLevel++;
        }

        // Coordinador inteligente de obstáculos
        function createObstacleSet(x) {
            const coordinator = game.obstacleCoordinator;

            // Actualizar nivel de dificultad
            coordinator.difficultyLevel = Math.min(game.stats.distance / 50, 1);

            // Seleccionar patrón basado en historia y dificultad
            const pattern = selectObstaclePattern();

            // Crear obstáculos según el patrón seleccionado
            executeObstaclePattern(pattern, x);

            // Crear monedas más frecuentemente
            if (Math.random() < 0.7 && game.level.coinsInLevel < game.level.totalCoinsInLevel) {
                // Crear múltiples monedas en diferentes posiciones
                const numCoins = 1 + Math.floor(Math.random() * 3);
                for (let i = 0; i < numCoins && game.level.coinsInLevel < game.level.totalCoinsInLevel; i++) {
                    createCoin(x + 30 + i * 40 + Math.random() * 50);
                }
            }

            // Actualizar historial
            updatePatternHistory(pattern);
        }

        function selectObstaclePattern() {
            const coordinator = game.obstacleCoordinator;
            const difficulty = coordinator.difficultyLevel;

            // Definir patrones disponibles según dificultad
            let availablePatterns = [];

            if (difficulty < 0.2) {
                // Fase inicial: patrones simples
                availablePatterns = ['ground_only', 'ceiling_only'];
            } else if (difficulty < 0.4) {
                // Fase temprana: introducir variedad y gravedad
                availablePatterns = ['ground_only', 'ceiling_only', 'alternating_simple', 'gravity_focused'];
            } else if (difficulty < 0.6) {
                // Fase intermedia: patrones más complejos
                availablePatterns = ['ground_only', 'ceiling_only', 'alternating_simple', 'narrow_passage', 'staggered', 'gravity_focused'];
            } else if (difficulty < 0.8) {
                // Fase avanzada: todos los patrones incluyendo desafíos de gravedad
                availablePatterns = ['ground_only', 'ceiling_only', 'alternating_simple', 'narrow_passage', 'staggered', 'zigzag', 'tunnel', 'gravity_challenge'];
            } else {
                // Fase experta: patrones complejos con mayor probabilidad
                availablePatterns = ['narrow_passage', 'staggered', 'zigzag', 'tunnel', 'chaos', 'gravity_challenge', 'gravity_focused'];
            }

            // Evitar repetir el mismo patrón demasiadas veces
            if (coordinator.patternStreak >= 3) {
                availablePatterns = availablePatterns.filter(p => p !== coordinator.lastPattern);
            }

            // Seleccionar patrón aleatorio de los disponibles
            return availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
        }

        function executeObstaclePattern(pattern, x) {
            const spacing = calculateDynamicSpacing();
            const coordinator = game.obstacleCoordinator;

            // Adaptar patrón según gravedad si está habilitado
            if (coordinator.gravityAwareMode) {
                pattern = adaptPatternToGravity(pattern);
            }

            switch (pattern) {
                case 'ground_only':
                    createObstacle(x);
                    break;

                case 'ceiling_only':
                    createUpperObstacle(x);
                    break;

                case 'gravity_focused':
                    // Patrón que favorece el lado opuesto a la gravedad actual
                    if (game.player.gravityInverted) {
                        createObstacle(x); // Más obstáculos del suelo cuando gravedad invertida
                        if (Math.random() < 0.3) createUpperObstacle(x + spacing * 0.8);
                    } else {
                        createUpperObstacle(x); // Más obstáculos del techo cuando gravedad normal
                        if (Math.random() < 0.3) createObstacle(x + spacing * 0.8);
                    }
                    break;

                case 'alternating_simple':
                    if (Math.random() < 0.5) {
                        createObstacle(x);
                        createUpperObstacle(x + spacing * 0.6);
                    } else {
                        createUpperObstacle(x);
                        createObstacle(x + spacing * 0.6);
                    }
                    break;

                case 'narrow_passage':
                    // Pasillo estrecho con obstáculos arriba y abajo
                    createObstacle(x);
                    createUpperObstacle(x + 15);
                    break;

                case 'gravity_challenge':
                    // Patrón que requiere cambio de gravedad
                    if (game.player.gravityInverted) {
                        createUpperObstacle(x);
                        createObstacle(x + 60);
                        createUpperObstacle(x + 120);
                    } else {
                        createObstacle(x);
                        createUpperObstacle(x + 60);
                        createObstacle(x + 120);
                    }
                    break;

                case 'staggered':
                    // Obstáculos escalonados
                    createObstacle(x);
                    createUpperObstacle(x + 40);
                    createObstacle(x + 80);
                    break;

                case 'zigzag':
                    // Patrón zigzag
                    createObstacle(x);
                    createUpperObstacle(x + 60);
                    createObstacle(x + 120);
                    createUpperObstacle(x + 180);
                    break;

                case 'tunnel':
                    // Túnel con obstáculos en ambos lados
                    createObstacle(x);
                    createUpperObstacle(x + 10);
                    createObstacle(x + 80);
                    createUpperObstacle(x + 90);
                    break;

                case 'chaos':
                    // Patrón caótico para máxima dificultad
                    const numObstacles = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < numObstacles; i++) {
                        const offsetX = i * (30 + Math.random() * 40);
                        if (Math.random() < 0.5) {
                            createObstacle(x + offsetX);
                        } else {
                            createUpperObstacle(x + offsetX);
                        }
                    }
                    break;
            }
        }

        // Adaptar patrón según el estado de gravedad
        function adaptPatternToGravity(pattern) {
            const coordinator = game.obstacleCoordinator;
            const gravityInverted = game.player.gravityInverted;

            // Si el jugador ha cambiado la gravedad recientemente, crear desafíos apropiados
            if (coordinator.gravityChangeCount > 0) {

                // Cada 3 cambios de gravedad, crear un desafío específico
                if (coordinator.gravityChangeCount % 3 === 0 && Math.random() < 0.4) {
                    return 'gravity_challenge';
                }

                // Favorecer patrones que aprovechen la gravedad actual
                if (Math.random() < 0.3) {
                    return 'gravity_focused';
                }
            }

            // Adaptar patrones existentes según gravedad
            switch (pattern) {
                case 'ground_only':
                    // Si gravedad invertida, ocasionalmente cambiar a ceiling_only
                    if (gravityInverted && Math.random() < 0.4) {
                        return 'ceiling_only';
                    }
                    break;

                case 'ceiling_only':
                    // Si gravedad normal, ocasionalmente cambiar a ground_only
                    if (!gravityInverted && Math.random() < 0.4) {
                        return 'ground_only';
                    }
                    break;
            }

            return pattern; // Mantener patrón original si no hay adaptación
        }

        function calculateDynamicSpacing() {
            const coordinator = game.obstacleCoordinator;
            const difficulty = coordinator.difficultyLevel;

            // Espaciado que se reduce con la dificultad
            const baseSpacing = coordinator.minSpacing +
                (coordinator.maxSpacing - coordinator.minSpacing) * (1 - difficulty);

            // Agregar variación aleatoria
            const variation = baseSpacing * 0.3;
            return baseSpacing + (Math.random() - 0.5) * variation;
        }

        function updatePatternHistory(pattern) {
            const coordinator = game.obstacleCoordinator;

            // Actualizar racha de patrones
            if (pattern === coordinator.lastPattern) {
                coordinator.patternStreak++;
            } else {
                coordinator.patternStreak = 1;
                coordinator.lastPattern = pattern;
            }

            // Mantener historial de últimos 10 patrones
            coordinator.patternHistory.push(pattern);
            if (coordinator.patternHistory.length > 10) {
                coordinator.patternHistory.shift();
            }
        }

        // Sistema de colisiones bidireccional avanzado
        function checkCollisions() {
            const player = game.player;

            // Verificar colisiones con obstáculos del suelo
            game.obstacles.forEach((obstacle, index) => {
                if (checkPreciseCollision(player, obstacle)) {
                    handleCollision(player, obstacle, 'ground', index);
                }
            });

            // Verificar colisiones con obstáculos superiores
            game.upperObstacles.forEach((obstacle, index) => {
                if (checkPreciseCollision(player, obstacle)) {
                    handleCollision(player, obstacle, 'ceiling', index);
                }
            });
        }

        // Detección de colisión precisa usando hitboxes
        function checkPreciseCollision(player, obstacle) {
            // Calcular hitboxes reales
            const playerHitbox = {
                x: player.x + player.hitbox.offsetX,
                y: player.y + player.hitbox.offsetY,
                width: player.hitbox.width,
                height: player.hitbox.height
            };

            const obstacleHitbox = {
                x: obstacle.x + obstacle.hitbox.offsetX,
                y: obstacle.y + obstacle.hitbox.offsetY,
                width: obstacle.hitbox.width,
                height: obstacle.hitbox.height
            };

            // Detección AABB (Axis-Aligned Bounding Box)
            return playerHitbox.x < obstacleHitbox.x + obstacleHitbox.width &&
                playerHitbox.x + playerHitbox.width > obstacleHitbox.x &&
                playerHitbox.y < obstacleHitbox.y + obstacleHitbox.height &&
                playerHitbox.y + playerHitbox.height > obstacleHitbox.y;
        }

        // Manejo de colisiones con información detallada
        function handleCollision(player, obstacle, type, index) {
            // Evitar múltiples colisiones
            if (game.isColliding) return;
            game.isColliding = true;

            // Información de debug
            console.log(`💥 Colisión detectada:`, {
                type: type,
                obstacleIndex: index,
                playerPos: { x: player.x, y: player.y },
                obstaclePos: { x: obstacle.x, y: obstacle.y },
                playerVel: { x: player.velX, y: player.velY },
                gravityInverted: player.gravityInverted
            });

            // Detener movimiento del jugador
            player.velX = 0;
            player.velY = 0;

            // Efecto visual de colisión
            showCollisionEffect(player.x + player.width / 2, player.y + player.height / 2);

            // Iniciar secuencia de game over con retardo
            startGameOverSequence();
        }

        // Efecto visual de colisión mejorado
        function showCollisionEffect(x, y) {
            // Crear efecto de partículas más dramático
            const effect = {
                x: x,
                y: y,
                particles: [],
                duration: 90 // Duración más larga para ver el efecto
            };

            // Crear más partículas para efecto más dramático
            for (let i = 0; i < 16; i++) {
                effect.particles.push({
                    x: x,
                    y: y,
                    velX: (Math.random() - 0.5) * 15,
                    velY: (Math.random() - 0.5) * 15,
                    life: 60 + Math.random() * 30,
                    size: 2 + Math.random() * 3
                });
            }

            // Agregar efecto temporal
            game.collisionEffect = effect;
        }

        // Iniciar secuencia de game over con retardo y fadeout
        function startGameOverSequence() {
            game.gameOverSequence.active = true;
            game.gameOverSequence.timer = 0;
            game.gameOverSequence.fadeAlpha = 0;

            console.log('🎬 Iniciando secuencia de game over...');
        }

        // Detección de colisiones cercanas (para advertencias)
        function checkNearCollisions() {
            const player = game.player;
            const warningDistance = 50;
            let nearObstacles = 0;

            // Verificar obstáculos del suelo cercanos
            game.obstacles.forEach(obstacle => {
                const distance = Math.abs((obstacle.x + obstacle.width / 2) - (player.x + player.width / 2));
                if (distance < warningDistance &&
                    Math.abs((obstacle.y + obstacle.height / 2) - (player.y + player.height / 2)) < 100) {
                    nearObstacles++;
                }
            });

            // Verificar obstáculos superiores cercanos
            game.upperObstacles.forEach(obstacle => {
                const distance = Math.abs((obstacle.x + obstacle.width / 2) - (player.x + player.width / 2));
                if (distance < warningDistance &&
                    Math.abs((obstacle.y + obstacle.height / 2) - (player.y + player.height / 2)) < 100) {
                    nearObstacles++;
                }
            });

            return nearObstacles;
        }

        // Test de colisiones (función de debug)
        function testCollisionSystem() {
            console.log('🧪 Ejecutando tests de colisiones...');

            // Test 1: Colisión básica
            const testPlayer = {
                x: 100, y: 100, width: 30, height: 30,
                hitbox: { offsetX: 3, offsetY: 3, width: 24, height: 24 }
            };

            const testObstacle = {
                x: 110, y: 110, width: 20, height: 50,
                hitbox: { offsetX: 2, offsetY: 2, width: 16, height: 46 }
            };

            const collision1 = checkPreciseCollision(testPlayer, testObstacle);
            console.log('Test 1 - Colisión básica:', collision1 ? '✅ PASS' : '❌ FAIL');

            // Test 2: Sin colisión
            testObstacle.x = 200;
            const collision2 = checkPreciseCollision(testPlayer, testObstacle);
            console.log('Test 2 - Sin colisión:', !collision2 ? '✅ PASS' : '❌ FAIL');

            // Test 3: Colisión por borde
            testObstacle.x = 124; // Justo en el borde
            const collision3 = checkPreciseCollision(testPlayer, testObstacle);
            console.log('Test 3 - Colisión por borde:', !collision3 ? '✅ PASS' : '❌ FAIL');

            console.log('🧪 Tests de colisiones completados');
        }

        function drawWorldGrid(ctx) {
            const bounds = game.world.bounds;
            const gridSize = 50;

            // Calcular qué líneas del grid están visibles
            const visibleLeft = Math.max(bounds.left, game.camera.x - gridSize);
            const visibleRight = Math.min(bounds.right, game.camera.x + game.canvas.width + gridSize);
            const visibleTop = Math.max(bounds.top, game.camera.y - gridSize);
            const visibleBottom = Math.min(bounds.bottom, game.camera.y + game.canvas.height + gridSize);

            // Configurar estilo del grid
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 0.5;
            ctx.globalAlpha = 0.3;

            // Líneas verticales
            const startX = Math.floor(visibleLeft / gridSize) * gridSize;
            for (let x = startX; x <= visibleRight; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, visibleTop);
                ctx.lineTo(x, visibleBottom);
                ctx.stroke();
            }

            // Líneas horizontales
            const startY = Math.floor(visibleTop / gridSize) * gridSize;
            for (let y = startY; y <= visibleBottom; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(visibleLeft, y);
                ctx.lineTo(visibleRight, y);
                ctx.stroke();
            }

            // Grid especial en el nivel del suelo principal (más visible)
            ctx.strokeStyle = '#555555';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.5;

            const groundY = game.world.surface.groundY;
            if (groundY >= visibleTop && groundY <= visibleBottom) {
                ctx.beginPath();
                ctx.moveTo(visibleLeft, groundY);
                ctx.lineTo(visibleRight, groundY);
                ctx.stroke();
            }

            // Restaurar alpha
            ctx.globalAlpha = 1.0;
        }

        function drawWorldSurfaces(ctx) {
            const surface = game.world.surface;
            const bounds = game.world.bounds;

            // Calcular qué parte del mundo está visible
            const visibleLeft = Math.max(bounds.left, game.camera.x - 100);
            const visibleRight = Math.min(bounds.right, game.camera.x + game.canvas.width + 100);
            const visibleTop = Math.max(bounds.top, game.camera.y - 100);
            const visibleBottom = Math.min(bounds.bottom, game.camera.y + game.canvas.height + 100);

            ctx.fillStyle = '#404040';

            // Dibujar suelo principal (se extiende por todo el ancho del mundo)
            if (surface.groundY >= visibleTop && surface.groundY <= visibleBottom) {
                ctx.fillRect(
                    visibleLeft,
                    surface.groundY,
                    visibleRight - visibleLeft,
                    surface.thickness
                );
            }

            // Dibujar techo principal (se extiende por todo el ancho del mundo)
            if (surface.ceilingY >= visibleTop && surface.ceilingY + surface.thickness <= visibleBottom) {
                ctx.fillRect(
                    visibleLeft,
                    surface.ceilingY,
                    visibleRight - visibleLeft,
                    surface.thickness
                );
            }

            // Dibujar plataformas adicionales para exploración vertical
            drawAdditionalPlatforms(ctx, visibleLeft, visibleRight, visibleTop, visibleBottom);
        }

        function drawAdditionalPlatforms(ctx, visibleLeft, visibleRight, visibleTop, visibleBottom) {
            ctx.fillStyle = '#606060'; // Color ligeramente diferente para plataformas adicionales

            // Plataformas superiores
            const upperPlatforms = [
                { y: -100, width: 200, x: 500 },
                { y: -200, width: 300, x: 1000 },
                { y: -150, width: 150, x: 1800 },
                { y: -300, width: 250, x: 2500 },
                { y: -100, width: 180, x: 3200 },
                { y: -250, width: 220, x: 4000 }
            ];

            // Plataformas inferiores
            const lowerPlatforms = [
                { y: 600, width: 250, x: 800 },
                { y: 700, width: 200, x: 1500 },
                { y: 650, width: 300, x: 2200 },
                { y: 750, width: 180, x: 3000 },
                { y: 680, width: 220, x: 3800 },
                { y: 720, width: 160, x: 4500 }
            ];

            // Dibujar plataformas superiores
            upperPlatforms.forEach(platform => {
                if (platform.x + platform.width >= visibleLeft &&
                    platform.x <= visibleRight &&
                    platform.y >= visibleTop &&
                    platform.y <= visibleBottom) {
                    ctx.fillRect(platform.x, platform.y, platform.width, 20);
                }
            });

            // Dibujar plataformas inferiores
            lowerPlatforms.forEach(platform => {
                if (platform.x + platform.width >= visibleLeft &&
                    platform.x <= visibleRight &&
                    platform.y >= visibleTop &&
                    platform.y <= visibleBottom) {
                    ctx.fillRect(platform.x, platform.y, platform.width, 20);
                }
            });
        }

        function render() {
            const ctx = game.ctx;

            // Limpiar canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);

            // Aplicar transformación de cámara
            ctx.save();
            ctx.translate(-game.camera.x, -game.camera.y);

            // Dibujar grid mundial que se extiende por todo el mundo
            drawWorldGrid(ctx);

            // Dibujar superficies del mundo (suelo y techo extendidos)
            drawWorldSurfaces(ctx);

            // Dibujar jugador con efecto de peligro
            const dangerLevel = calculateDangerLevel();

            // Color del jugador basado en el peligro
            if (dangerLevel === 0) {
                ctx.fillStyle = '#FFFFFF'; // Blanco normal
            } else if (dangerLevel === 1) {
                ctx.fillStyle = '#F0F0F0'; // Ligeramente más tenue
            } else {
                ctx.fillStyle = '#E0E0E0'; // Más tenue (máximo peligro)
            }

            ctx.fillRect(game.player.x, game.player.y, game.player.width, game.player.height);

            // Agregar borde de advertencia si hay peligro
            if (dangerLevel > 0) {
                ctx.strokeStyle = dangerLevel === 1 ? '#C0C0C0' : '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(game.player.x - 1, game.player.y - 1, game.player.width + 2, game.player.height + 2);
            }

            // Dibujar obstáculos del suelo
            ctx.fillStyle = '#808080';
            game.obstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });

            // Dibujar obstáculos superiores
            ctx.fillStyle = '#606060'; // Ligeramente más oscuros para diferenciación
            game.upperObstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                // Agregar pequeño detalle visual (líneas de "colgado")
                ctx.strokeStyle = '#404040';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const lineX = obstacle.x + (obstacle.width / 4) * (i + 1);
                    ctx.beginPath();
                    ctx.moveTo(lineX, obstacle.y);
                    ctx.lineTo(lineX, obstacle.y + 10);
                    ctx.stroke();
                }
            });

            // Dibujar monedas
            game.coins.forEach(coin => {
                if (!coin.collected) {
                    // Animación de rotación
                    const time = Date.now() * 0.005;
                    const scale = 0.8 + Math.sin(time + coin.animationOffset) * 0.2;

                    ctx.save();
                    ctx.translate(coin.x + coin.width / 2, coin.y + coin.height / 2);
                    ctx.scale(scale, scale);

                    // Dibujar moneda dorada
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(0, 0, coin.width / 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Borde más oscuro
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Símbolo de moneda
                    ctx.fillStyle = '#FF8C00';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('$', 0, 3);

                    ctx.restore();
                }
            });

            // Efectos de dash
            if (!game.player.dashAvailable) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(game.player.x - 5, game.player.y - 5, game.player.width + 10, game.player.height + 10);
            }

            // Renderizar efecto de colisión
            if (game.collisionEffect) {
                renderCollisionEffect(ctx);
            }

            // Renderizar efecto de cambio de gravedad
            if (game.gravityEffect) {
                renderGravityEffect(ctx);
            }

            // Renderizar efecto de recolección de monedas
            if (game.coinEffect) {
                renderCoinEffect(ctx);
            }

            // Renderizar hitboxes de debug (solo si está habilitado)
            if (game.config.showHitboxes) {
                renderDebugHitboxes(ctx);
            }

            // Renderizar fadeout de game over
            if (game.gameOverSequence.active && game.gameOverSequence.fadeAlpha > 0) {
                ctx.fillStyle = `rgba(0, 0, 0, ${game.gameOverSequence.fadeAlpha})`;
                ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);
            }

            // Restaurar transformación de cámara
            ctx.restore();

            // Renderizar minimapa (sin transformación de cámara)
            renderMinimap();
        }

        function jump() {
            if (game.player.jumpsLeft > 0) {
                const jumpForce = game.player.gravityInverted ? 12 : -12;
                game.player.velY = jumpForce;
                game.player.jumpsLeft--;
                game.player.onGround = false;

                updateHUD();
            }
        }

        function dash() {
            if (game.player.dashAvailable) {
                game.player.velX = game.keys['KeyA'] || game.keys['ArrowLeft'] ? -10 : 10;
                game.player.dashAvailable = false;

                updateHUD();
            }
        }

        function toggleGravity() {
            const wasInverted = game.player.gravityInverted;
            game.player.gravityInverted = !game.player.gravityInverted;

            // Transición suave de velocidad
            game.player.velY = game.player.velY * -0.3; // Invertir y reducir velocidad

            // Actualizar contador de cambios de gravedad
            game.obstacleCoordinator.gravityChangeCount++;
            game.obstacleCoordinator.lastGravityState = game.player.gravityInverted;

            // Efecto visual de cambio de gravedad
            showGravityChangeEffect();

            // Log para debug
            console.log(`🔄 Gravedad cambiada: ${wasInverted ? '↑' : '↓'} → ${game.player.gravityInverted ? '↑' : '↓'}`);
            console.log(`📊 Cambios de gravedad totales: ${game.obstacleCoordinator.gravityChangeCount}`);

            updateHUD();
        }

        // Efecto visual para cambio de gravedad
        function showGravityChangeEffect() {
            const player = game.player;
            const effect = {
                x: player.x + player.width / 2,
                y: player.y + player.height / 2,
                particles: [],
                duration: 45
            };

            // Crear partículas que se mueven según la nueva gravedad
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const speed = 3 + Math.random() * 2;
                effect.particles.push({
                    x: effect.x,
                    y: effect.y,
                    velX: Math.cos(angle) * speed,
                    velY: Math.sin(angle) * speed * (game.player.gravityInverted ? -1 : 1),
                    life: 45,
                    size: 1 + Math.random() * 2
                });
            }

            game.gravityEffect = effect;
        }

        function updateHUD() {
            document.getElementById('distanceDisplay').textContent = Math.floor(game.stats.distance) + 'm';
            document.getElementById('jumpsDisplay').textContent = game.player.jumpsLeft;
            document.getElementById('dashDisplay').textContent = game.player.dashAvailable ? '✓' : '✗';
            document.getElementById('gravityDisplay').textContent = game.player.gravityInverted ? '↑' : '↓';
            document.getElementById('coinsDisplay').textContent = game.stats.coins;
            document.getElementById('levelDisplay').textContent = game.level.current;
            document.getElementById('progressDisplay').textContent = Math.floor(game.stats.levelProgress) + '%';

            // Mostrar posición actual del jugador
            const currentPosition = Math.floor(game.player.x * 0.1);
            const maxPosition = Math.floor(game.world.bounds.right * 0.1);
            document.getElementById('positionDisplay').textContent = `${currentPosition}/${maxPosition}m`;

            // Mostrar altura relativa (0 = nivel del suelo principal)
            const groundLevel = game.world.surface.groundY;
            const altitude = Math.floor((groundLevel - game.player.y) * 0.1);
            document.getElementById('altitudeDisplay').textContent = `${altitude}m`;

            // Calcular nivel de peligro basado en obstáculos cercanos
            const dangerLevel = calculateDangerLevel();
            const dangerElement = document.getElementById('dangerLevel');

            if (dangerLevel === 0) {
                dangerElement.textContent = '●';
                dangerElement.style.color = '#808080'; // Gris
            } else if (dangerLevel === 1) {
                dangerElement.textContent = '●●';
                dangerElement.style.color = '#C0C0C0'; // Gris claro
            } else {
                dangerElement.textContent = '●●●';
                dangerElement.style.color = '#FFFFFF'; // Blanco (máximo peligro)
            }

            // Actualizar indicador de dificultad
            const difficultyLevel = game.obstacleCoordinator.difficultyLevel;
            const difficultyElement = document.getElementById('difficultyLevel');

            if (difficultyLevel < 0.2) {
                difficultyElement.textContent = 'I';
                difficultyElement.style.color = '#808080';
            } else if (difficultyLevel < 0.4) {
                difficultyElement.textContent = 'II';
                difficultyElement.style.color = '#909090';
            } else if (difficultyLevel < 0.6) {
                difficultyElement.textContent = 'III';
                difficultyElement.style.color = '#A0A0A0';
            } else if (difficultyLevel < 0.8) {
                difficultyElement.textContent = 'IV';
                difficultyElement.style.color = '#B0B0B0';
            } else {
                difficultyElement.textContent = 'V';
                difficultyElement.style.color = '#FFFFFF';
            }
        }

        function calculateDangerLevel() {
            // Usar el nuevo sistema de detección de colisiones cercanas
            const nearObstacles = checkNearCollisions();

            // Retornar nivel de peligro (0-2)
            return Math.min(nearObstacles, 2);
        }

        function togglePause() {
            game.paused = !game.paused;
            document.getElementById('pauseBtn').textContent = game.paused ? 'REANUDAR' : 'PAUSA';
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function toggleMinimap() {
            const minimapContainer = document.getElementById('minimapContainer');
            game.minimap.visible = !game.minimap.visible;

            if (game.minimap.visible) {
                minimapContainer.classList.remove('hidden');
            } else {
                minimapContainer.classList.add('hidden');
            }
        }

        function renderMinimap() {
            if (!game.minimap.visible) return;

            const minimapCanvas = document.getElementById('minimapCanvas');
            const minimapCtx = minimapCanvas.getContext('2d');

            // Limpiar minimapa
            minimapCtx.fillStyle = '#000000';
            minimapCtx.fillRect(0, 0, game.minimap.width, game.minimap.height);

            // Calcular offsets del minimapa centrados en el jugador
            const playerScreenX = game.player.x * game.minimap.scale;
            const playerScreenY = game.player.y * game.minimap.scale;

            game.minimap.offsetX = Math.max(0, Math.min(
                (game.world.bounds.right * game.minimap.scale) - game.minimap.width,
                playerScreenX - game.minimap.width / 2
            ));

            game.minimap.offsetY = Math.max(0, Math.min(
                (game.world.bounds.bottom * game.minimap.scale) - game.minimap.height,
                playerScreenY - game.minimap.height / 2
            ));

            // Dibujar grid del minimapa
            minimapCtx.strokeStyle = '#222222';
            minimapCtx.lineWidth = 0.5;
            const gridSize = 50 * game.minimap.scale;

            for (let x = -game.minimap.offsetX % gridSize; x < game.minimap.width; x += gridSize) {
                minimapCtx.beginPath();
                minimapCtx.moveTo(x, 0);
                minimapCtx.lineTo(x, game.minimap.height);
                minimapCtx.stroke();
            }

            for (let y = -game.minimap.offsetY % gridSize; y < game.minimap.height; y += gridSize) {
                minimapCtx.beginPath();
                minimapCtx.moveTo(0, y);
                minimapCtx.lineTo(game.minimap.width, y);
                minimapCtx.stroke();
            }

            // Dibujar superficies principales (suelo y techo)
            minimapCtx.fillStyle = '#404040';
            const groundY = (game.world.surface.groundY * game.minimap.scale) - game.minimap.offsetY;
            const ceilingY = (game.world.surface.ceilingY * game.minimap.scale) - game.minimap.offsetY;
            const thickness = game.world.surface.thickness * game.minimap.scale;

            if (groundY >= 0 && groundY <= game.minimap.height) {
                minimapCtx.fillRect(0, groundY, game.minimap.width, thickness);
            }
            if (ceilingY >= 0 && ceilingY <= game.minimap.height) {
                minimapCtx.fillRect(0, ceilingY, game.minimap.width, thickness);
            }

            // Dibujar plataformas adicionales
            minimapCtx.fillStyle = '#606060';
            const platforms = [
                // Plataformas superiores
                { y: -100, width: 200, x: 500 }, { y: -200, width: 300, x: 1000 },
                { y: -150, width: 150, x: 1800 }, { y: -300, width: 250, x: 2500 },
                { y: -100, width: 180, x: 3200 }, { y: -250, width: 220, x: 4000 },
                // Plataformas inferiores
                { y: 600, width: 250, x: 800 }, { y: 700, width: 200, x: 1500 },
                { y: 650, width: 300, x: 2200 }, { y: 750, width: 180, x: 3000 },
                { y: 680, width: 220, x: 3800 }, { y: 720, width: 160, x: 4500 }
            ];

            platforms.forEach(platform => {
                const x = (platform.x * game.minimap.scale) - game.minimap.offsetX;
                const y = (platform.y * game.minimap.scale) - game.minimap.offsetY;
                const width = platform.width * game.minimap.scale;
                const height = 20 * game.minimap.scale;

                if (x + width >= 0 && x <= game.minimap.width &&
                    y + height >= 0 && y <= game.minimap.height) {
                    minimapCtx.fillRect(x, y, width, height);
                }
            });

            // Dibujar obstáculos
            minimapCtx.fillStyle = '#808080';
            [...game.obstacles, ...game.upperObstacles].forEach(obstacle => {
                const x = (obstacle.x * game.minimap.scale) - game.minimap.offsetX;
                const y = (obstacle.y * game.minimap.scale) - game.minimap.offsetY;
                const width = obstacle.width * game.minimap.scale;
                const height = obstacle.height * game.minimap.scale;

                if (x + width >= 0 && x <= game.minimap.width &&
                    y + height >= 0 && y <= game.minimap.height) {
                    minimapCtx.fillRect(x, y, width, height);
                }
            });

            // Dibujar monedas con diferentes colores según su ubicación
            game.coins.forEach(coin => {
                if (!coin.collected) {
                    const x = (coin.x * game.minimap.scale) - game.minimap.offsetX;
                    const y = (coin.y * game.minimap.scale) - game.minimap.offsetY;
                    const size = Math.max(2, coin.width * game.minimap.scale);

                    if (x + size >= 0 && x <= game.minimap.width &&
                        y + size >= 0 && y <= game.minimap.height) {

                        // Color según la dificultad de acceso
                        if (coin.y < game.world.surface.ceilingY + 100) {
                            minimapCtx.fillStyle = '#00FFFF'; // Cyan para áreas superiores
                        } else if (coin.y > game.world.surface.groundY - 100) {
                            minimapCtx.fillStyle = '#FF6B6B'; // Rojo para áreas inferiores
                        } else {
                            minimapCtx.fillStyle = '#FFD700'; // Dorado para área principal
                        }

                        minimapCtx.fillRect(x, y, size, size);
                    }
                }
            });

            // Dibujar jugador con indicador de dirección
            const playerX = (game.player.x * game.minimap.scale) - game.minimap.offsetX;
            const playerY = (game.player.y * game.minimap.scale) - game.minimap.offsetY;
            const playerSize = Math.max(3, game.player.width * game.minimap.scale);

            // Fondo del jugador
            minimapCtx.fillStyle = '#000000';
            minimapCtx.fillRect(playerX - 1, playerY - 1, playerSize + 2, playerSize + 2);

            // Jugador
            minimapCtx.fillStyle = '#FFFFFF';
            minimapCtx.fillRect(playerX, playerY, playerSize, playerSize);

            // Indicador de gravedad
            minimapCtx.fillStyle = game.player.gravityInverted ? '#FF6B6B' : '#00FF00';
            const indicatorSize = 2;
            const indicatorY = game.player.gravityInverted ? playerY - 3 : playerY + playerSize + 1;
            minimapCtx.fillRect(playerX + playerSize / 2 - indicatorSize / 2, indicatorY, indicatorSize, indicatorSize);

            // Dibujar límites del mundo
            minimapCtx.strokeStyle = '#666666';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(0, 0, game.minimap.width, game.minimap.height);

            // Indicador de progreso del nivel
            minimapCtx.strokeStyle = '#FFD700';
            minimapCtx.lineWidth = 2;
            const progressWidth = (game.stats.levelProgress / 100) * game.minimap.width;
            minimapCtx.strokeRect(0, game.minimap.height - 3, progressWidth, 3);
        }

        function gameOver() {
            console.log('🎮 Ejecutando gameOver()');

            // Detener el juego
            game.running = false;

            // Resetear estado de secuencia
            game.gameOverSequence.active = false;
            game.gameOverSequence.timer = 0;
            game.gameOverSequence.fadeAlpha = 0;

            // Mostrar estadísticas de patrones en consola
            console.log('🎮 Estadísticas de la partida:');
            console.log('Distancia:', Math.floor(game.stats.distance) + 'm');
            console.log('Dificultad final:', (game.obstacleCoordinator.difficultyLevel * 100).toFixed(1) + '%');
            console.log('Cambios de gravedad:', game.obstacleCoordinator.gravityChangeCount);
            console.log('Último patrón:', game.obstacleCoordinator.lastPattern);
            console.log('Historial de patrones:', game.obstacleCoordinator.patternHistory);
            console.log('🎬 Secuencia de game over completada');

            // Actualizar récords
            const currentDistance = Math.floor(game.stats.distance);
            const bestDistance = parseInt(localStorage.getItem('bestDistance') || '0');

            if (currentDistance > bestDistance) {
                localStorage.setItem('bestDistance', currentDistance.toString());
                document.getElementById('bestDistance').textContent = currentDistance;
            }

            const gamesPlayed = parseInt(localStorage.getItem('gamesPlayed') || '0') + 1;
            localStorage.setItem('gamesPlayed', gamesPlayed.toString());
            document.getElementById('gamesPlayed').textContent = gamesPlayed;

            // Mostrar pantalla de game over con transición suave
            document.getElementById('finalDistance').textContent = currentDistance;
            showScreen('gameOverScreen');

            console.log('🎮 gameOver() completado, pantalla mostrada');
        }

        // Balanceador dinámico de dificultad
        function balanceDifficulty() {
            const coordinator = game.obstacleCoordinator;
            const player = game.player;

            // Ajustar espaciado basado en el rendimiento del jugador
            if (player.jumpsLeft === 0 && !player.onGround) {
                // Jugador en problemas, reducir dificultad ligeramente
                coordinator.minSpacing = Math.min(coordinator.minSpacing + 0.5, 180);
                coordinator.maxSpacing = Math.min(coordinator.maxSpacing + 0.5, 320);
            } else if (player.jumpsLeft === 2 && player.dashAvailable) {
                // Jugador en buena forma, puede aumentar dificultad
                coordinator.minSpacing = Math.max(coordinator.minSpacing - 0.2, 120);
                coordinator.maxSpacing = Math.max(coordinator.maxSpacing - 0.2, 280);
            }

            // Bonus por uso inteligente de gravedad
            if (coordinator.gravityChangeCount > 0) {
                const gravityBonus = Math.min(coordinator.gravityChangeCount * 2, 20);
                coordinator.minSpacing = Math.max(coordinator.minSpacing - gravityBonus * 0.1, 100);
                coordinator.maxSpacing = Math.max(coordinator.maxSpacing - gravityBonus * 0.1, 250);
            }

            // Mantener límites razonables
            coordinator.minSpacing = Math.max(100, Math.min(180, coordinator.minSpacing));
            coordinator.maxSpacing = Math.max(250, Math.min(350, coordinator.maxSpacing));
        }

        // Renderizar efecto de colisión mejorado
        function renderCollisionEffect(ctx) {
            const effect = game.collisionEffect;
            if (!effect) return;

            // Actualizar y renderizar partículas
            effect.particles.forEach(particle => {
                // Actualizar posición
                particle.x += particle.velX;
                particle.y += particle.velY;
                particle.velX *= 0.92; // Fricción más gradual
                particle.velY *= 0.92;
                particle.life--;

                // Renderizar partícula con tamaño variable
                if (particle.life > 0) {
                    const alpha = particle.life / 60;
                    const size = particle.size * alpha;

                    // Partículas blancas con glow
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fillRect(particle.x - size / 2, particle.y - size / 2, size, size);

                    // Efecto de glow
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
                    ctx.fillRect(particle.x - size, particle.y - size, size * 2, size * 2);
                }
            });

            // Remover efecto cuando termine
            effect.duration--;
            if (effect.duration <= 0) {
                game.collisionEffect = null;
            }
        }

        // Renderizar efecto de cambio de gravedad
        function renderGravityEffect(ctx) {
            const effect = game.gravityEffect;
            if (!effect) return;

            // Actualizar y renderizar partículas
            effect.particles.forEach(particle => {
                // Actualizar posición
                particle.x += particle.velX;
                particle.y += particle.velY;
                particle.velX *= 0.98; // Fricción ligera
                particle.velY *= 0.98;
                particle.life--;

                // Renderizar partícula con color según gravedad
                if (particle.life > 0) {
                    const alpha = particle.life / 45;
                    const size = particle.size * alpha;

                    // Color diferente según gravedad
                    const color = game.player.gravityInverted ? '200, 200, 255' : '255, 200, 200';

                    ctx.fillStyle = `rgba(${color}, ${alpha})`;
                    ctx.fillRect(particle.x - size / 2, particle.y - size / 2, size, size);
                }
            });

            // Remover efecto cuando termine
            effect.duration--;
            if (effect.duration <= 0) {
                game.gravityEffect = null;
            }
        }

        // Renderizar efecto de recolección de monedas
        function renderCoinEffect(ctx) {
            const effect = game.coinEffect;
            if (!effect) return;

            // Actualizar y renderizar partículas doradas
            effect.particles.forEach(particle => {
                // Actualizar posición
                particle.x += particle.velX;
                particle.y += particle.velY;
                particle.velX *= 0.95;
                particle.velY *= 0.95;
                particle.life--;

                // Renderizar partícula dorada
                if (particle.life > 0) {
                    const alpha = particle.life / 30;
                    const size = particle.size * alpha;

                    // Partículas doradas brillantes
                    ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                    ctx.fillRect(particle.x - size / 2, particle.y - size / 2, size, size);

                    // Efecto de brillo
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                    ctx.fillRect(particle.x - size / 4, particle.y - size / 4, size / 2, size / 2);
                }
            });

            // Remover efecto cuando termine
            effect.duration--;
            if (effect.duration <= 0) {
                game.coinEffect = null;
            }
        }

        // Renderizar hitboxes de debug
        function renderDebugHitboxes(ctx) {
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 1;

            // Hitbox del jugador
            const playerHitbox = {
                x: game.player.x + game.player.hitbox.offsetX,
                y: game.player.y + game.player.hitbox.offsetY,
                width: game.player.hitbox.width,
                height: game.player.hitbox.height
            };
            ctx.strokeRect(playerHitbox.x, playerHitbox.y, playerHitbox.width, playerHitbox.height);

            // Hitboxes de obstáculos del suelo
            ctx.strokeStyle = '#00FF00';
            game.obstacles.forEach(obstacle => {
                const hitbox = {
                    x: obstacle.x + obstacle.hitbox.offsetX,
                    y: obstacle.y + obstacle.hitbox.offsetY,
                    width: obstacle.hitbox.width,
                    height: obstacle.hitbox.height
                };
                ctx.strokeRect(hitbox.x, hitbox.y, hitbox.width, hitbox.height);
            });

            // Hitboxes de obstáculos superiores
            ctx.strokeStyle = '#0000FF';
            game.upperObstacles.forEach(obstacle => {
                const hitbox = {
                    x: obstacle.x + obstacle.hitbox.offsetX,
                    y: obstacle.y + obstacle.hitbox.offsetY,
                    width: obstacle.hitbox.width,
                    height: obstacle.hitbox.height
                };
                ctx.strokeRect(hitbox.x, hitbox.y, hitbox.width, hitbox.height);
            });
        }

        // Inicializar cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', () => {
            init();

            // Cargar récords
            document.getElementById('bestDistance').textContent = localStorage.getItem('bestDistance') || '0';
            document.getElementById('gamesPlayed').textContent = localStorage.getItem('gamesPlayed') || '0';

            console.log('✅ Spikepulse Noir Edition cargado correctamente');
        });

        console.log('✅ Sistema noir básico aplicado');
    </script>
</body>

</html>