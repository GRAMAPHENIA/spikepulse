<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spikepulse - Simple Working Version</title>

    <style>
        /* Estilo noir cinematogr√°fico mejorado */
        :root {
            --noir-white: #FFFFFF;
            --noir-light: #E0E0E0;
            --noir-medium: #808080;
            --noir-dark: #404040;
            --noir-black: #000000;
            --font-main: 'Courier New', monospace;

            /* Nuevos colores cinematogr√°ficos */
            --noir-deep-black: #0a0a0a;
            --noir-charcoal: #1a1a1a;
            --noir-steel: #2a2a2a;
            --noir-silver: #c0c0c0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-main);
            background:
                radial-gradient(ellipse at top, var(--noir-charcoal) 0%, var(--noir-deep-black) 50%, var(--noir-black) 100%),
                linear-gradient(135deg, var(--noir-black) 0%, var(--noir-charcoal) 25%, var(--noir-steel) 50%, var(--noir-charcoal) 75%, var(--noir-black) 100%);
            color: var(--noir-white);
            overflow: hidden;
            user-select: none;
            min-height: 100vh;
        }

        /* Fondo con grid cinematogr√°fico m√°s elegante */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 75% 75%, rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, transparent 98%, rgba(255, 255, 255, 0.05) 100%),
                linear-gradient(0deg, transparent 98%, rgba(255, 255, 255, 0.05) 100%);
            background-size: 80px 80px, 120px 120px, 60px 60px, 60px 60px;
            opacity: 0.6;
            z-index: -1;
            animation: gridFloat 20s linear infinite;
        }

        @keyframes gridFloat {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(-60px, -60px);
            }
        }

        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            background:
                radial-gradient(ellipse at center, rgba(26, 26, 26, 0.95) 0%, rgba(10, 10, 10, 0.98) 70%),
                linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(26, 26, 26, 0.9) 50%, rgba(0, 0, 0, 0.95) 100%);
            backdrop-filter: blur(10px);
        }

        .screen.hidden {
            display: none;
        }

        .title {
            font-size: 4rem;
            font-weight: bold;
            letter-spacing: 0.3em;
            margin-bottom: 1rem;
            color: var(--noir-white);
            text-shadow:
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 20px rgba(255, 255, 255, 0.5),
                0 0 30px rgba(255, 255, 255, 0.3),
                0 0 40px rgba(255, 255, 255, 0.1);
            animation: titleGlow 4s ease-in-out infinite;
        }

        @keyframes titleGlow {

            0%,
            100% {
                text-shadow:
                    0 0 10px rgba(255, 255, 255, 0.8),
                    0 0 20px rgba(255, 255, 255, 0.5),
                    0 0 30px rgba(255, 255, 255, 0.3);
            }

            50% {
                text-shadow:
                    0 0 15px rgba(255, 255, 255, 1),
                    0 0 30px rgba(255, 255, 255, 0.7),
                    0 0 45px rgba(255, 255, 255, 0.5),
                    0 0 60px rgba(255, 255, 255, 0.3);
            }
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--noir-silver);
            margin-bottom: 3rem;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
            letter-spacing: 0.1em;
            animation: subtitleFade 2s ease-out;
        }

        @keyframes subtitleFade {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }

            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .btn {
            background: linear-gradient(145deg,
                    rgba(64, 64, 64, 0.3) 0%,
                    rgba(26, 26, 26, 0.8) 50%,
                    rgba(0, 0, 0, 0.9) 100%);
            border: 2px solid var(--noir-silver);
            color: var(--noir-white);
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: bold;
            padding: 1rem 2.5rem;
            margin: 0.5rem 0;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            width: 250px;
            border-radius: 8px;
            box-shadow:
                0 4px 15px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .btn:hover {
            background: linear-gradient(145deg,
                    rgba(255, 255, 255, 0.9) 0%,
                    rgba(240, 240, 240, 0.95) 50%,
                    rgba(220, 220, 220, 1) 100%);
            color: var(--noir-black);
            border-color: var(--noir-white);
            box-shadow:
                0 6px 25px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(255, 255, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            text-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            transform: translateY(-3px) scale(1.02);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(-1px) scale(1.01);
        }

        .btn--primary {
            border-color: var(--noir-white);
            margin-bottom: 1.5rem;
            box-shadow:
                0 6px 20px rgba(0, 0, 0, 0.7),
                0 0 15px rgba(255, 255, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .game-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }

        .game-area.hidden {
            display: none;
        }

        canvas {
            border: 1px solid var(--noir-dark);
            background: var(--noir-black);
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--noir-light);
            z-index: 200;
        }

        .hud.hidden {
            display: none;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.2rem;
        }

        .hud-label {
            font-size: 0.6rem;
            color: var(--noir-medium);
            text-transform: uppercase;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 380px;
            /* Mover para no interferir con el minimapa m√°s grande */
            display: flex;
            gap: 0.5rem;
            z-index: 200;
        }

        .controls.hidden {
            display: none;
        }

        .control-btn {
            background: transparent;
            border: 1px solid var(--noir-dark);
            color: var(--noir-medium);
            font-family: inherit;
            font-size: 0.6rem;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
        }

        .control-btn:hover {
            border-color: var(--noir-medium);
            color: var(--noir-white);
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6rem;
            color: var(--noir-medium);
            text-align: center;
            z-index: 200;
        }

        .instructions.hidden {
            display: none;
        }

        /* Minimapa */
        .minimap-container {
            position: fixed;
            top: 20px;
            right: 20px;
            /* Posici√≥n m√°s accesible */
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.95), rgba(26, 26, 26, 0.9));
            border: 2px solid var(--noir-silver);
            border-radius: 12px;
            padding: 15px;
            z-index: 300;
            backdrop-filter: blur(10px);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .minimap-container.hidden {
            display: none;
        }

        .minimap-title {
            color: var(--noir-white);
            font-size: 0.7rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }

        #minimapCanvas {
            border: 1px solid var(--noir-dark);
            background: var(--noir-black);
            display: block;
        }
    </style>
</head>

<body>
    <!-- Pantalla de inicio -->
    <div id="startScreen" class="screen">
        <h1 class="title">SPIKEPULSE</h1>
        <p class="subtitle">Simple Working Version</p>

        <button id="startBtn" class="btn btn--primary">COMENZAR</button>
        <button id="recordsBtn" class="btn">R√âCORDS</button>
        <button id="configBtn" class="btn">CONFIG</button>
    </div>

    <!-- Pantalla de r√©cords -->
    <div id="recordsScreen" class="screen hidden">
        <h2 class="title" style="font-size: 2rem;">R√âCORDS</h2>
        <div style="margin: 2rem 0;">
            <p style="margin: 1rem 0;">Mejor Distancia: <span id="bestDistance">0</span>m</p>
            <p style="margin: 1rem 0;">Partidas: <span id="gamesPlayed">0</span></p>
        </div>
        <button id="backFromRecords" class="btn">VOLVER</button>
    </div>

    <!-- Pantalla de configuraci√≥n -->
    <div id="configScreen" class="screen hidden">
        <h2 class="title" style="font-size: 2rem;">CONFIG</h2>
        <div style="margin: 2rem 0;">
            <label style="display: block; margin: 1rem 0;">
                <input type="checkbox" id="showFPS" style="margin-right: 0.5rem;">
                Mostrar FPS
            </label>
            <label style="display: block; margin: 1rem 0;">
                <input type="checkbox" id="particles" checked style="margin-right: 0.5rem;">
                Part√≠culas
            </label>
        </div>
        <button id="backFromConfig" class="btn">VOLVER</button>
    </div>

    <!-- Pantalla de Game Over -->
    <div id="gameOverScreen" class="screen hidden">
        <h2 class="title" style="font-size: 2rem;">GAME OVER</h2>
        <p class="subtitle">Distancia: <span id="finalDistance">0</span>m</p>
        <button id="restartBtn" class="btn btn--primary">REINTENTAR</button>
        <button id="menuBtn" class="btn">MEN√ö</button>
    </div>

    <!-- √Årea de juego -->
    <div id="gameArea" class="game-area hidden">
        <canvas id="gameCanvas" width="1200" height="600"></canvas>
    </div>

    <!-- HUD -->
    <div id="gameHUD" class="hud hidden">
        <div class="hud-item">
            <div class="hud-label">Distancia</div>
            <div id="distanceDisplay">0m</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">Saltos</div>
            <div id="jumpsDisplay">2</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">Dash</div>
            <div id="dashDisplay">‚úì</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">Gravedad</div>
            <div id="gravityDisplay">‚Üì</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Peligro</div>
            <div id="dangerLevel">‚óè</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Dificultad</div>
            <div id="difficultyLevel">I</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Monedas</div>
            <div id="coinsDisplay">0</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Nivel</div>
            <div id="levelDisplay">1</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Progreso</div>
            <div id="progressDisplay">0%</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Posici√≥n</div>
            <div id="positionDisplay">0m</div>
        </div>

        <div class="hud-item">
            <div class="hud-label">Altura</div>
            <div id="altitudeDisplay">0m</div>
        </div>
    </div>

    <!-- Controles -->
    <div id="gameControls" class="controls hidden">
        <button id="pauseBtn" class="control-btn">PAUSA</button>
        <button id="fullscreenBtn" class="control-btn">‚õ∂</button>
        <button id="minimapBtn" class="control-btn">MAPA</button>
    </div>

    <!-- Minimapa -->
    <div id="minimapContainer" class="minimap-container hidden">
        <div class="minimap-title">MINIMAPA</div>
        <canvas id="minimapCanvas" width="300" height="150"></canvas>
    </div>

    <!-- Instrucciones -->
    <div id="instructions" class="instructions hidden">
        ESPACIO: Saltar | A/D: Mover | W/S: Explorar Vertical | SHIFT: Dash | CTRL: Gravedad | ¬°Evita obst√°culos
        superiores! | CTRL+H: Hitboxes |
        CTRL+T: Tests
    </div>

    <script>
        console.log('üéÆ Iniciando Spikepulse...');

        // Aplicar estilo noir b√°sico
        document.body.style.background = 'radial-gradient(ellipse at top, #1a1a1a 0%, #0a0a0a 50%, #000000 100%)';

        // Mejorar t√≠tulo
        setTimeout(() => {
            const title = document.querySelector('.title');
            if (title) {
                title.style.color = '#ffffff';
                title.style.textShadow = '0 0 20px rgba(255,255,255,0.8)';
            }

            const subtitle = document.querySelector('.subtitle');
            if (subtitle) {
                subtitle.textContent = 'Noir Edition - Domina la Gravedad';
                subtitle.style.color = '#c0c0c0';
            }
        }, 100);

        // Estado del juego
        const game = {
            canvas: document.getElementById('gameCanvas'),
            ctx: null,
            running: false,
            paused: false,

            // Jugador
            player: {
                x: 100,
                y: 300,
                width: 30,
                height: 30,
                velY: 0,
                velX: 0,
                onGround: false,
                jumpsLeft: 2,
                dashAvailable: true,
                gravityInverted: false,
                // Hitbox del jugador (ligeramente m√°s peque√±a para mejor jugabilidad)
                hitbox: {
                    offsetX: 3,
                    offsetY: 3,
                    width: 24,
                    height: 24
                }
            },

            // Mundo expandido para exploraci√≥n vertical y horizontal
            world: {
                gravity: 0.5,
                // L√≠mites del mundo expandido
                bounds: {
                    left: 0,
                    right: 5000,  // Ancho total del mundo
                    top: -500,    // Permite explorar hacia arriba
                    bottom: 900   // Permite explorar hacia abajo
                },
                // Zonas de superficie (donde hay suelo/techo)
                surface: {
                    groundY: 370,     // Nivel del suelo principal
                    ceilingY: 30,     // Nivel del techo principal
                    thickness: 30     // Grosor del suelo/techo
                },
                speed: 0 // Sin movimiento autom√°tico - exploraci√≥n libre
            },

            // Obst√°culos
            obstacles: [],
            upperObstacles: [],

            // Monedas
            coins: [],

            // Configuraci√≥n de nivel
            level: {
                current: 1,
                targetDistance: 500, // Distancia m√°s larga para completar el nivel
                coinsInLevel: 0,
                totalCoinsInLevel: 50, // M√°s monedas totales en el nivel
                width: 2000, // Ancho total del nivel
                height: 400  // Alto del nivel
            },

            // Stats
            stats: {
                distance: 0,
                startTime: 0,
                coins: 0,
                totalCoins: parseInt(localStorage.getItem('totalCoins') || '0'),
                level: 1,
                levelProgress: 0
            },

            // Estado de colisi√≥n
            isColliding: false,
            gameOverSequence: {
                active: false,
                timer: 0,
                fadeAlpha: 0
            },

            // Input
            keys: {},

            // Config
            config: {
                showFPS: false,
                particles: true,
                showHitboxes: false
            },

            // Coordinador de obst√°culos
            obstacleCoordinator: {
                lastPattern: null,
                patternStreak: 0,
                minSpacing: 150,
                maxSpacing: 300,
                difficultyLevel: 0,
                patternHistory: [],
                gravityAwareMode: true,
                lastGravityState: false,
                gravityChangeCount: 0
            },

            // Minimapa mejorado
            minimap: {
                width: 300,
                height: 150,
                scale: 0.06, // Escala m√°s peque√±a para mostrar m√°s √°rea
                offsetX: 0, // Desplazamiento horizontal
                offsetY: 0, // Desplazamiento vertical para exploraci√≥n vertical
                visible: true,
                showVertical: true // Mostrar exploraci√≥n vertical
            },

            // C√°mara para exploraci√≥n libre
            camera: {
                x: 0,
                y: 0,
                followPlayer: true,
                smoothing: 0.15 // Suavizado del seguimiento m√°s responsivo
            }
        };

        // Inicializaci√≥n
        function init() {
            game.canvas = document.getElementById('gameCanvas');
            game.ctx = game.canvas.getContext('2d');

            console.log('üéÆ Inicializando juego...');
            console.log('Canvas:', game.canvas);
            console.log('Context:', game.ctx);

            // Event listeners
            setupEventListeners();

            console.log('‚úÖ Juego inicializado correctamente');
        }

        function setupEventListeners() {
            // Botones de navegaci√≥n
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('recordsBtn').addEventListener('click', () => showScreen('recordsScreen'));
            document.getElementById('configBtn').addEventListener('click', () => showScreen('configScreen'));
            document.getElementById('backFromRecords').addEventListener('click', () => showScreen('startScreen'));
            document.getElementById('backFromConfig').addEventListener('click', () => showScreen('startScreen'));
            document.getElementById('restartBtn').addEventListener('click', startGame);
            document.getElementById('menuBtn').addEventListener('click', () => showScreen('startScreen'));

            // Controles del juego
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

            // Teclado
            document.addEventListener('keydown', (e) => {
                game.keys[e.code] = true;

                // Controles espec√≠ficos
                if (e.code === 'Space' && game.running) {
                    e.preventDefault();
                    jump();
                }
                if (e.code === 'ShiftLeft' && game.running) {
                    dash();
                }
                if (e.code === 'ControlLeft' && game.running) {
                    toggleGravity();
                }
                if (e.code === 'Escape') {
                    if (game.running) togglePause();
                }

                // Debug: mostrar/ocultar hitboxes
                if (e.code === 'KeyH' && e.ctrlKey) {
                    game.config.showHitboxes = !game.config.showHitboxes;
                    console.log('Hitboxes de debug:', game.config.showHitboxes ? 'activadas' : 'desactivadas');
                }

                // Debug: ejecutar tests de colisiones
                if (e.code === 'KeyT' && e.ctrlKey) {
                    testCollisionSystem();
                }
            });

            document.addEventListener('keyup', (e) => {
                game.keys[e.code] = false;
            });

            // Click para saltar
            game.canvas.addEventListener('click', () => {
                if (game.running) jump();
            });

            // Bot√≥n del minimapa
            document.getElementById('minimapBtn').addEventListener('click', toggleMinimap);
        }

        function showScreen(screenId) {
            // Ocultar todas las pantallas
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.add('hidden');
            });

            // Ocultar elementos del juego
            document.getElementById('gameArea').classList.add('hidden');
            document.getElementById('gameHUD').classList.add('hidden');
            document.getElementById('gameControls').classList.add('hidden');
            document.getElementById('instructions').classList.add('hidden');

            // Mostrar pantalla solicitada
            document.getElementById(screenId).classList.remove('hidden');

            // Parar el juego si est√° corriendo
            if (game.running) {
                game.running = false;
            }
        }

        function startGame() {
            console.log('üéÆ Iniciando juego...');
            console.log('Estado antes de resetear:', {
                running: game.running,
                paused: game.paused,
                isColliding: game.isColliding,
                gameOverSequence: game.gameOverSequence.active
            });

            // Ocultar pantallas
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.add('hidden');
            });

            // Mostrar elementos del juego
            document.getElementById('gameArea').classList.remove('hidden');
            document.getElementById('gameHUD').classList.remove('hidden');
            document.getElementById('gameControls').classList.remove('hidden');
            document.getElementById('instructions').classList.remove('hidden');

            // Mostrar minimapa
            if (game.minimap.visible) {
                document.getElementById('minimapContainer').classList.remove('hidden');
            }

            // Resetear juego
            resetGame();

            // Iniciar loop
            game.running = true;
            game.paused = false;
            game.stats.startTime = Date.now();

            console.log('Estado despu√©s de resetear:', {
                running: game.running,
                paused: game.paused,
                isColliding: game.isColliding,
                gameOverSequence: game.gameOverSequence.active
            });

            gameLoop();
            console.log('üéÆ Juego iniciado correctamente');
        }

        function resetGame() {
            // Resetear jugador
            game.player.x = 100;
            game.player.y = 200; // Posici√≥n m√°s centrada entre suelo y techo
            game.player.velY = 0;
            game.player.velX = 0;
            game.player.onGround = false;
            game.player.jumpsLeft = 2;
            game.player.dashAvailable = true;
            game.player.gravityInverted = false;

            // Resetear obst√°culos y monedas
            game.obstacles = [];
            game.upperObstacles = [];
            game.coins = [];

            // Resetear nivel
            game.level.current = 1;
            game.level.targetDistance = 500;
            game.level.coinsInLevel = 0;
            game.level.totalCoinsInLevel = 50;
            game.level.width = 5000; // Nivel mucho m√°s amplio para exploraci√≥n

            // Resetear c√°mara
            game.camera.x = 0;
            game.camera.y = 0;

            // Resetear stats
            game.stats.distance = 0;
            game.stats.coins = 0;
            game.stats.levelProgress = 0;

            // Resetear coordinador de obst√°culos
            game.obstacleCoordinator.lastPattern = null;
            game.obstacleCoordinator.patternStreak = 0;
            game.obstacleCoordinator.difficultyLevel = 0;
            game.obstacleCoordinator.patternHistory = [];
            game.obstacleCoordinator.lastGravityState = false;
            game.obstacleCoordinator.gravityChangeCount = 0;

            // Resetear estado de colisi√≥n
            game.isColliding = false;
            game.gameOverSequence.active = false;
            game.gameOverSequence.timer = 0;
            game.gameOverSequence.fadeAlpha = 0;
            game.collisionEffect = null;
            game.gravityEffect = null;

            // Generar contenido inicial del nivel
            generateInitialLevelContent();
        }

        function gameLoop() {
            if (!game.running) return;

            // Siempre actualizar si hay secuencia de game over activa
            if (game.gameOverSequence.active) {
                updateGameOverSequence();
            } else if (!game.paused) {
                update();
            }

            render();

            requestAnimationFrame(gameLoop);
        }

        function update() {
            // Actualizar jugador
            updatePlayer();

            // Actualizar obst√°culos
            updateObstacles();

            // Actualizar monedas
            updateCoins();

            // Actualizar c√°mara
            updateCamera();

            // Actualizar stats (ahora basado en la posici√≥n del jugador)
            game.stats.distance = Math.max(game.stats.distance, game.player.x * 0.1);

            // Verificar progreso del nivel
            checkLevelProgress();

            // Balanceador din√°mico de dificultad
            balanceDifficulty();

            // Actualizar HUD
            updateHUD();

            // Verificar colisiones
            checkCollisions();

            // Verificar recolecci√≥n de monedas
            checkCoinCollection();
        }

        function updateCamera() {
            if (game.camera.followPlayer) {
                // Seguir al jugador suavemente
                const targetX = game.player.x - game.canvas.width / 2;
                const targetY = game.player.y - game.canvas.height / 2;

                // Aplicar suavizado m√°s responsivo
                const smoothing = 0.15; // M√°s responsivo que antes
                game.camera.x += (targetX - game.camera.x) * smoothing;
                game.camera.y += (targetY - game.camera.y) * smoothing;

                // Limitar la c√°mara a los bordes del mundo expandido
                const bounds = game.world.bounds;
                game.camera.x = Math.max(bounds.left, Math.min(bounds.right - game.canvas.width, game.camera.x));
                game.camera.y = Math.max(bounds.top, Math.min(bounds.bottom - game.canvas.height, game.camera.y));
            }
        }

        function updateCoins() {
            // Las monedas ya no se mueven autom√°ticamente - est√°n fijas en el mundo
            // Solo remover monedas que est√©n muy lejos del jugador para optimizaci√≥n
            game.coins = game.coins.filter(coin => {
                const distance = Math.abs(coin.x - game.player.x);
                return distance < game.canvas.width * 2; // Mantener monedas en un rango amplio
            });
        }

        function checkCoinCollection() {
            const player = game.player;

            game.coins.forEach(coin => {
                if (!coin.collected && checkPreciseCollision(player, coin)) {
                    // Recolectar moneda
                    coin.collected = true;
                    game.stats.coins += coin.value;
                    game.stats.totalCoins += coin.value;

                    // Guardar monedas totales
                    localStorage.setItem('totalCoins', game.stats.totalCoins.toString());

                    // Efecto visual de recolecci√≥n
                    showCoinCollectionEffect(coin.x + coin.width / 2, coin.y + coin.height / 2);

                    console.log(`üí∞ Moneda recolectada! Total: ${game.stats.coins}`);
                }
            });
        }

        function checkLevelProgress() {
            // Progreso basado en la exploraci√≥n del nivel (posici√≥n m√°xima alcanzada)
            const maxDistance = game.level.width * 0.1; // Convertir a metros
            const progress = (game.stats.distance / maxDistance) * 100;
            game.stats.levelProgress = Math.min(progress, 100);

            // Verificar si se complet√≥ el nivel (alcanzar el 80% del nivel)
            if (game.stats.distance >= maxDistance * 0.8) {
                completeLevel();
            }
        }

        function completeLevel() {
            console.log(`üéâ ¬°Nivel ${game.level.current} completado!`);

            // Bonus por monedas recolectadas
            const coinBonus = game.stats.coins * 10;
            game.stats.totalCoins += coinBonus;
            localStorage.setItem('totalCoins', game.stats.totalCoins.toString());

            // Avanzar al siguiente nivel
            game.level.current++;
            game.level.targetDistance += 200; // Aumentar dificultad significativamente
            game.level.totalCoinsInLevel += 15; // Muchas m√°s monedas en niveles superiores
            game.level.width += 500; // Hacer el nivel m√°s ancho
            game.level.coinsInLevel = 0;

            // Resetear para el siguiente nivel
            game.stats.distance = 0;
            game.stats.coins = 0;
            game.obstacles = [];
            game.upperObstacles = [];
            game.coins = [];

            // Resetear posici√≥n del jugador y c√°mara
            game.player.x = 100;
            game.player.y = 200;
            game.camera.x = 0;
            game.camera.y = 0;

            // Generar contenido inicial del nuevo nivel
            generateInitialLevelContent();

            // Mostrar mensaje de nivel completado
            showLevelCompleteMessage(coinBonus);
        }

        function showCoinCollectionEffect(x, y) {
            // Efecto visual simple para recolecci√≥n de monedas
            const effect = {
                x: x,
                y: y,
                particles: [],
                duration: 30
            };

            // Crear part√≠culas doradas
            for (let i = 0; i < 8; i++) {
                effect.particles.push({
                    x: x,
                    y: y,
                    velX: (Math.random() - 0.5) * 8,
                    velY: (Math.random() - 0.5) * 8,
                    life: 30,
                    size: 2 + Math.random() * 2
                });
            }

            game.coinEffect = effect;
        }

        function generateVerticalCoins() {
            // Monedas en zonas superiores (requieren saltos m√∫ltiples o gravedad invertida)
            const upperChallengeAreas = [
                // Cerca de plataformas superiores
                { x: 580, y: -120 }, { x: 620, y: -140 }, { x: 660, y: -100 },
                { x: 1080, y: -220 }, { x: 1120, y: -240 }, { x: 1160, y: -200 }, { x: 1200, y: -180 },
                { x: 1880, y: -170 }, { x: 1920, y: -190 },
                { x: 2580, y: -320 }, { x: 2620, y: -340 }, { x: 2660, y: -300 }, { x: 2700, y: -280 },
                { x: 3280, y: -120 }, { x: 3320, y: -140 },
                { x: 4080, y: -270 }, { x: 4120, y: -290 }, { x: 4160, y: -250 },

                // Monedas en el aire (requieren dash + salto)
                { x: 750, y: -50 }, { x: 1350, y: -80 }, { x: 2000, y: -60 },
                { x: 2800, y: -100 }, { x: 3500, y: -70 }, { x: 4300, y: -90 },

                // Monedas muy altas (m√°ximo desaf√≠o)
                { x: 1000, y: -350 }, { x: 2500, y: -400 }, { x: 4000, y: -380 }
            ];

            // Monedas en zonas inferiores (requieren exploraci√≥n subterr√°nea)
            const lowerChallengeAreas = [
                // Cerca de plataformas inferiores
                { x: 880, y: 620 }, { x: 920, y: 640 }, { x: 960, y: 600 },
                { x: 1580, y: 720 }, { x: 1620, y: 740 }, { x: 1660, y: 700 },
                { x: 2280, y: 670 }, { x: 2320, y: 690 }, { x: 2360, y: 650 },
                { x: 3080, y: 770 }, { x: 3120, y: 790 }, { x: 3160, y: 750 },
                { x: 3880, y: 700 }, { x: 3920, y: 720 }, { x: 3960, y: 680 },
                { x: 4580, y: 740 }, { x: 4620, y: 760 }, { x: 4660, y: 720 },

                // Monedas en pozos profundos
                { x: 1200, y: 800 }, { x: 1800, y: 820 }, { x: 2600, y: 840 },
                { x: 3400, y: 810 }, { x: 4200, y: 830 },

                // Monedas muy profundas (m√°ximo desaf√≠o subterr√°neo)
                { x: 1500, y: 850 }, { x: 2500, y: 870 }, { x: 3500, y: 860 }
            ];

            // Monedas en ubicaciones especiales (requieren t√©cnicas avanzadas)
            const specialChallengeAreas = [
                // Entre obst√°culos (requieren timing perfecto)
                { x: 400, y: 200 }, { x: 800, y: 180 }, { x: 1200, y: 220 },
                { x: 1600, y: 160 }, { x: 2000, y: 240 }, { x: 2400, y: 200 },
                { x: 2800, y: 180 }, { x: 3200, y: 220 }, { x: 3600, y: 160 },
                { x: 4000, y: 240 }, { x: 4400, y: 200 }, { x: 4800, y: 180 },

                // Monedas que requieren cambio de gravedad
                { x: 600, y: 50 }, { x: 1000, y: 60 }, { x: 1400, y: 40 },
                { x: 1800, y: 70 }, { x: 2200, y: 50 }, { x: 2600, y: 60 },
                { x: 3000, y: 40 }, { x: 3400, y: 70 }, { x: 3800, y: 50 },
                { x: 4200, y: 60 }, { x: 4600, y: 40 }
            ];

            // Crear monedas en √°reas superiores
            upperChallengeAreas.forEach(area => {
                createCoin(area.x, area.y);
            });

            // Crear monedas en √°reas inferiores
            lowerChallengeAreas.forEach(area => {
                createCoin(area.x, area.y);
            });

            // Crear monedas especiales
            specialChallengeAreas.forEach(area => {
                createCoin(area.x, area.y);
            });
        }

        function generateInitialLevelContent() {
            console.log(`üèóÔ∏è Generando contenido para nivel ${game.level.current}...`);

            // Generar obst√°culos distribuidos por todo el nivel
            for (let x = 300; x < game.level.width; x += 150 + Math.random() * 300) {
                createObstacleSet(x);
            }

            // Generar monedas adicionales distribuidas por el nivel
            const coinsToGenerate = Math.max(0, game.level.totalCoinsInLevel - game.level.coinsInLevel);
            for (let i = 0; i < coinsToGenerate; i++) {
                const x = 200 + Math.random() * (game.level.width - 400);
                createCoin(x);
            }

            // Generar monedas adicionales distribuidas uniformemente
            for (let x = 500; x < game.level.width - 200; x += 200 + Math.random() * 100) {
                if (Math.random() < 0.7) { // 70% de probabilidad de generar moneda
                    createCoin(x);
                }
            }

            // Generar monedas en √°reas verticales para incentivar exploraci√≥n
            generateVerticalCoins();

            console.log(`‚úÖ Nivel generado: ${game.obstacles.length + game.upperObstacles.length} obst√°culos, ${game.coins.length} monedas`);
        }

        function showLevelCompleteMessage(bonus) {
            // Crear mensaje temporal
            const message = document.createElement('div');
            message.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(145deg, rgba(255,215,0,0.9), rgba(255,165,0,0.8));
                color: black;
                padding: 20px 30px;
                border-radius: 12px;
                font-family: 'Courier New', monospace;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 1000;
                box-shadow: 0 8px 25px rgba(0,0,0,0.8);
                border: 2px solid #FFD700;
            `;
            message.innerHTML = `
                <div>üéâ ¬°NIVEL ${game.level.current - 1} COMPLETADO! üéâ</div>
                <div style="font-size: 14px; margin-top: 10px;">
                    Bonus por monedas: +${bonus} monedas
                </div>
                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">
                    Iniciando Nivel ${game.level.current}...
                </div>
            `;
            document.body.appendChild(message);

            // Remover mensaje despu√©s de 3 segundos
            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
            }, 3000);
        }

        // Actualizar secuencia de game over
        function updateGameOverSequence() {
            const sequence = game.gameOverSequence;
            sequence.timer++;

            // Fase 1: Mostrar part√≠culas (primeros 60 frames = 1 segundo)
            if (sequence.timer <= 60) {
                // Solo actualizar efectos visuales, no hacer nada m√°s
                return;
            }

            // Fase 2: Fadeout (siguientes 30 frames = 0.5 segundos)
            if (sequence.timer <= 90) {
                sequence.fadeAlpha = (sequence.timer - 60) / 30;
                return;
            }

            // Fase 3: Ir a pantalla de game over
            console.log('üé¨ Finalizando secuencia, yendo a game over');
            gameOver();
        }

        function checkSurfaceCollision(player) {
            const surface = game.world.surface;

            if (!player.gravityInverted) {
                // Gravedad normal: verificar colisi√≥n con el suelo
                if (player.y + player.height >= surface.groundY &&
                    player.y + player.height <= surface.groundY + surface.thickness &&
                    player.velY >= 0) {
                    player.y = surface.groundY - player.height;
                    player.velY = 0;
                    return true;
                }

                // Verificar colisi√≥n con el techo desde abajo
                if (player.y <= surface.ceilingY + surface.thickness &&
                    player.y >= surface.ceilingY &&
                    player.velY <= 0) {
                    player.y = surface.ceilingY + surface.thickness;
                    player.velY = 0;
                    return false; // No est√° "en el suelo" cuando golpea el techo
                }
            } else {
                // Gravedad invertida: verificar colisi√≥n con el techo
                if (player.y <= surface.ceilingY + surface.thickness &&
                    player.y >= surface.ceilingY &&
                    player.velY <= 0) {
                    player.y = surface.ceilingY + surface.thickness;
                    player.velY = 0;
                    return true;
                }

                // Verificar colisi√≥n con el suelo desde arriba
                if (player.y + player.height >= surface.groundY &&
                    player.y + player.height <= surface.groundY + surface.thickness &&
                    player.velY >= 0) {
                    player.y = surface.groundY - player.height;
                    player.velY = 0;
                    return false; // No est√° "en el suelo" cuando golpea desde arriba
                }
            }

            return false;
        }

        function updatePlayer() {
            const player = game.player;

            // Movimiento horizontal
            if (game.keys['KeyA'] || game.keys['ArrowLeft']) {
                player.velX = Math.max(player.velX - 0.5, -5);
            } else if (game.keys['KeyD'] || game.keys['ArrowRight']) {
                player.velX = Math.min(player.velX + 0.5, 5);
            } else {
                player.velX *= 0.8; // Fricci√≥n
            }

            // Movimiento vertical para exploraci√≥n (W/S)
            if (game.keys['KeyW'] || game.keys['ArrowUp']) {
                player.velY = Math.max(player.velY - 0.3, -3); // Impulso hacia arriba
            } else if (game.keys['KeyS'] || game.keys['ArrowDown']) {
                player.velY = Math.min(player.velY + 0.3, 3); // Impulso hacia abajo
            }

            // Gravedad
            const gravity = player.gravityInverted ? -game.world.gravity : game.world.gravity;
            player.velY += gravity;

            // Aplicar velocidad
            player.x += player.velX;
            player.y += player.velY;

            // L√≠mites del mundo expandido
            if (player.x < game.world.bounds.left) player.x = game.world.bounds.left;
            if (player.x > game.world.bounds.right - player.width) {
                player.x = game.world.bounds.right - player.width;
            }
            if (player.y < game.world.bounds.top) player.y = game.world.bounds.top;
            if (player.y > game.world.bounds.bottom - player.height) {
                player.y = game.world.bounds.bottom - player.height;
            }

            // Colisi√≥n con superficies principales (suelo y techo)
            const onMainSurface = checkSurfaceCollision(player);

            if (onMainSurface) {
                player.onGround = true;
                player.jumpsLeft = 2;
                player.dashAvailable = true;
            } else {
                player.onGround = false;
            }
        }

        function updateObstacles() {
            // Los obst√°culos ya no se mueven - est√°n fijos en el mundo
            // Solo optimizar removiendo obst√°culos muy lejanos del jugador
            const playerX = game.player.x;
            const maxDistance = game.canvas.width * 3;

            game.obstacles = game.obstacles.filter(obstacle => {
                const distance = Math.abs(obstacle.x - playerX);
                return distance < maxDistance;
            });

            game.upperObstacles = game.upperObstacles.filter(obstacle => {
                const distance = Math.abs(obstacle.x - playerX);
                return distance < maxDistance;
            });

            // Generar m√°s contenido si el jugador se acerca al final del nivel generado
            const lastObstacle = game.obstacles[game.obstacles.length - 1];
            const lastUpperObstacle = game.upperObstacles[game.upperObstacles.length - 1];
            const lastX = Math.max(
                lastObstacle ? lastObstacle.x : 0,
                lastUpperObstacle ? lastUpperObstacle.x : 0
            );

            // Si el jugador est√° cerca del final del contenido generado, generar m√°s
            if (playerX > lastX - game.canvas.width * 2) {
                const dynamicSpacing = calculateDynamicSpacing();
                createObstacleSet(lastX + dynamicSpacing);
            }
        }

        function createObstacle(x) {
            const height = 40 + Math.random() * 60;
            const obstacle = {
                x: x,
                y: game.world.surface.groundY - height,
                width: 20,
                height: height,
                type: 'ground',
                // Hitbox m√°s precisa (ligeramente m√°s peque√±a que el visual)
                hitbox: {
                    offsetX: 2,
                    offsetY: 2,
                    width: 16,
                    height: height - 4
                }
            };
            game.obstacles.push(obstacle);
        }

        function createUpperObstacle(x) {
            const height = 40 + Math.random() * 80;
            const obstacle = {
                x: x,
                y: game.world.surface.ceilingY + game.world.surface.thickness,
                width: 20,
                height: height,
                type: 'ceiling',
                // Hitbox m√°s precisa para obst√°culos colgantes
                hitbox: {
                    offsetX: 2,
                    offsetY: 0,
                    width: 16,
                    height: height - 2
                }
            };
            game.upperObstacles.push(obstacle);
        }

        function createCoin(x, y) {
            const coin = {
                x: x,
                y: y || (game.world.surface.ceilingY + 80 + Math.random() * (game.world.surface.groundY - game.world.surface.ceilingY - 160)),
                width: 16,
                height: 16,
                collected: false,
                value: 1,
                animationOffset: Math.random() * Math.PI * 2, // Para animaci√≥n
                // Hitbox para recolecci√≥n
                hitbox: {
                    offsetX: 2,
                    offsetY: 2,
                    width: 12,
                    height: 12
                }
            };
            game.coins.push(coin);
            game.level.coinsInLevel++;
        }

        // Coordinador inteligente de obst√°culos
        function createObstacleSet(x) {
            const coordinator = game.obstacleCoordinator;

            // Actualizar nivel de dificultad
            coordinator.difficultyLevel = Math.min(game.stats.distance / 50, 1);

            // Seleccionar patr√≥n basado en historia y dificultad
            const pattern = selectObstaclePattern();

            // Crear obst√°culos seg√∫n el patr√≥n seleccionado
            executeObstaclePattern(pattern, x);

            // Crear monedas m√°s frecuentemente
            if (Math.random() < 0.7 && game.level.coinsInLevel < game.level.totalCoinsInLevel) {
                // Crear m√∫ltiples monedas en diferentes posiciones
                const numCoins = 1 + Math.floor(Math.random() * 3);
                for (let i = 0; i < numCoins && game.level.coinsInLevel < game.level.totalCoinsInLevel; i++) {
                    createCoin(x + 30 + i * 40 + Math.random() * 50);
                }
            }

            // Actualizar historial
            updatePatternHistory(pattern);
        }

        function selectObstaclePattern() {
            const coordinator = game.obstacleCoordinator;
            const difficulty = coordinator.difficultyLevel;

            // Definir patrones disponibles seg√∫n dificultad
            let availablePatterns = [];

            if (difficulty < 0.2) {
                // Fase inicial: patrones simples
                availablePatterns = ['ground_only', 'ceiling_only'];
            } else if (difficulty < 0.4) {
                // Fase temprana: introducir variedad y gravedad
                availablePatterns = ['ground_only', 'ceiling_only', 'alternating_simple', 'gravity_focused'];
            } else if (difficulty < 0.6) {
                // Fase intermedia: patrones m√°s complejos
                availablePatterns = ['ground_only', 'ceiling_only', 'alternating_simple', 'narrow_passage', 'staggered', 'gravity_focused'];
            } else if (difficulty < 0.8) {
                // Fase avanzada: todos los patrones incluyendo desaf√≠os de gravedad
                availablePatterns = ['ground_only', 'ceiling_only', 'alternating_simple', 'narrow_passage', 'staggered', 'zigzag', 'tunnel', 'gravity_challenge'];
            } else {
                // Fase experta: patrones complejos con mayor probabilidad
                availablePatterns = ['narrow_passage', 'staggered', 'zigzag', 'tunnel', 'chaos', 'gravity_challenge', 'gravity_focused'];
            }

            // Evitar repetir el mismo patr√≥n demasiadas veces
            if (coordinator.patternStreak >= 3) {
                availablePatterns = availablePatterns.filter(p => p !== coordinator.lastPattern);
            }

            // Seleccionar patr√≥n aleatorio de los disponibles
            return availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
        }

        function executeObstaclePattern(pattern, x) {
            const spacing = calculateDynamicSpacing();
            const coordinator = game.obstacleCoordinator;

            // Adaptar patr√≥n seg√∫n gravedad si est√° habilitado
            if (coordinator.gravityAwareMode) {
                pattern = adaptPatternToGravity(pattern);
            }

            switch (pattern) {
                case 'ground_only':
                    createObstacle(x);
                    break;

                case 'ceiling_only':
                    createUpperObstacle(x);
                    break;

                case 'gravity_focused':
                    // Patr√≥n que favorece el lado opuesto a la gravedad actual
                    if (game.player.gravityInverted) {
                        createObstacle(x); // M√°s obst√°culos del suelo cuando gravedad invertida
                        if (Math.random() < 0.3) createUpperObstacle(x + spacing * 0.8);
                    } else {
                        createUpperObstacle(x); // M√°s obst√°culos del techo cuando gravedad normal
                        if (Math.random() < 0.3) createObstacle(x + spacing * 0.8);
                    }
                    break;

                case 'alternating_simple':
                    if (Math.random() < 0.5) {
                        createObstacle(x);
                        createUpperObstacle(x + spacing * 0.6);
                    } else {
                        createUpperObstacle(x);
                        createObstacle(x + spacing * 0.6);
                    }
                    break;

                case 'narrow_passage':
                    // Pasillo estrecho con obst√°culos arriba y abajo
                    createObstacle(x);
                    createUpperObstacle(x + 15);
                    break;

                case 'gravity_challenge':
                    // Patr√≥n que requiere cambio de gravedad
                    if (game.player.gravityInverted) {
                        createUpperObstacle(x);
                        createObstacle(x + 60);
                        createUpperObstacle(x + 120);
                    } else {
                        createObstacle(x);
                        createUpperObstacle(x + 60);
                        createObstacle(x + 120);
                    }
                    break;

                case 'staggered':
                    // Obst√°culos escalonados
                    createObstacle(x);
                    createUpperObstacle(x + 40);
                    createObstacle(x + 80);
                    break;

                case 'zigzag':
                    // Patr√≥n zigzag
                    createObstacle(x);
                    createUpperObstacle(x + 60);
                    createObstacle(x + 120);
                    createUpperObstacle(x + 180);
                    break;

                case 'tunnel':
                    // T√∫nel con obst√°culos en ambos lados
                    createObstacle(x);
                    createUpperObstacle(x + 10);
                    createObstacle(x + 80);
                    createUpperObstacle(x + 90);
                    break;

                case 'chaos':
                    // Patr√≥n ca√≥tico para m√°xima dificultad
                    const numObstacles = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < numObstacles; i++) {
                        const offsetX = i * (30 + Math.random() * 40);
                        if (Math.random() < 0.5) {
                            createObstacle(x + offsetX);
                        } else {
                            createUpperObstacle(x + offsetX);
                        }
                    }
                    break;
            }
        }

        // Adaptar patr√≥n seg√∫n el estado de gravedad
        function adaptPatternToGravity(pattern) {
            const coordinator = game.obstacleCoordinator;
            const gravityInverted = game.player.gravityInverted;

            // Si el jugador ha cambiado la gravedad recientemente, crear desaf√≠os apropiados
            if (coordinator.gravityChangeCount > 0) {

                // Cada 3 cambios de gravedad, crear un desaf√≠o espec√≠fico
                if (coordinator.gravityChangeCount % 3 === 0 && Math.random() < 0.4) {
                    return 'gravity_challenge';
                }

                // Favorecer patrones que aprovechen la gravedad actual
                if (Math.random() < 0.3) {
                    return 'gravity_focused';
                }
            }

            // Adaptar patrones existentes seg√∫n gravedad
            switch (pattern) {
                case 'ground_only':
                    // Si gravedad invertida, ocasionalmente cambiar a ceiling_only
                    if (gravityInverted && Math.random() < 0.4) {
                        return 'ceiling_only';
                    }
                    break;

                case 'ceiling_only':
                    // Si gravedad normal, ocasionalmente cambiar a ground_only
                    if (!gravityInverted && Math.random() < 0.4) {
                        return 'ground_only';
                    }
                    break;
            }

            return pattern; // Mantener patr√≥n original si no hay adaptaci√≥n
        }

        function calculateDynamicSpacing() {
            const coordinator = game.obstacleCoordinator;
            const difficulty = coordinator.difficultyLevel;

            // Espaciado que se reduce con la dificultad
            const baseSpacing = coordinator.minSpacing +
                (coordinator.maxSpacing - coordinator.minSpacing) * (1 - difficulty);

            // Agregar variaci√≥n aleatoria
            const variation = baseSpacing * 0.3;
            return baseSpacing + (Math.random() - 0.5) * variation;
        }

        function updatePatternHistory(pattern) {
            const coordinator = game.obstacleCoordinator;

            // Actualizar racha de patrones
            if (pattern === coordinator.lastPattern) {
                coordinator.patternStreak++;
            } else {
                coordinator.patternStreak = 1;
                coordinator.lastPattern = pattern;
            }

            // Mantener historial de √∫ltimos 10 patrones
            coordinator.patternHistory.push(pattern);
            if (coordinator.patternHistory.length > 10) {
                coordinator.patternHistory.shift();
            }
        }

        // Sistema de colisiones bidireccional avanzado
        function checkCollisions() {
            const player = game.player;

            // Verificar colisiones con obst√°culos del suelo
            game.obstacles.forEach((obstacle, index) => {
                if (checkPreciseCollision(player, obstacle)) {
                    handleCollision(player, obstacle, 'ground', index);
                }
            });

            // Verificar colisiones con obst√°culos superiores
            game.upperObstacles.forEach((obstacle, index) => {
                if (checkPreciseCollision(player, obstacle)) {
                    handleCollision(player, obstacle, 'ceiling', index);
                }
            });
        }

        // Detecci√≥n de colisi√≥n precisa usando hitboxes
        function checkPreciseCollision(player, obstacle) {
            // Calcular hitboxes reales
            const playerHitbox = {
                x: player.x + player.hitbox.offsetX,
                y: player.y + player.hitbox.offsetY,
                width: player.hitbox.width,
                height: player.hitbox.height
            };

            const obstacleHitbox = {
                x: obstacle.x + obstacle.hitbox.offsetX,
                y: obstacle.y + obstacle.hitbox.offsetY,
                width: obstacle.hitbox.width,
                height: obstacle.hitbox.height
            };

            // Detecci√≥n AABB (Axis-Aligned Bounding Box)
            return playerHitbox.x < obstacleHitbox.x + obstacleHitbox.width &&
                playerHitbox.x + playerHitbox.width > obstacleHitbox.x &&
                playerHitbox.y < obstacleHitbox.y + obstacleHitbox.height &&
                playerHitbox.y + playerHitbox.height > obstacleHitbox.y;
        }

        // Manejo de colisiones con informaci√≥n detallada
        function handleCollision(player, obstacle, type, index) {
            // Evitar m√∫ltiples colisiones
            if (game.isColliding) return;
            game.isColliding = true;

            // Informaci√≥n de debug
            console.log(`üí• Colisi√≥n detectada:`, {
                type: type,
                obstacleIndex: index,
                playerPos: { x: player.x, y: player.y },
                obstaclePos: { x: obstacle.x, y: obstacle.y },
                playerVel: { x: player.velX, y: player.velY },
                gravityInverted: player.gravityInverted
            });

            // Detener movimiento del jugador
            player.velX = 0;
            player.velY = 0;

            // Efecto visual de colisi√≥n
            showCollisionEffect(player.x + player.width / 2, player.y + player.height / 2);

            // Iniciar secuencia de game over con retardo
            startGameOverSequence();
        }

        // Efecto visual de colisi√≥n mejorado
        function showCollisionEffect(x, y) {
            // Crear efecto de part√≠culas m√°s dram√°tico
            const effect = {
                x: x,
                y: y,
                particles: [],
                duration: 90 // Duraci√≥n m√°s larga para ver el efecto
            };

            // Crear m√°s part√≠culas para efecto m√°s dram√°tico
            for (let i = 0; i < 16; i++) {
                effect.particles.push({
                    x: x,
                    y: y,
                    velX: (Math.random() - 0.5) * 15,
                    velY: (Math.random() - 0.5) * 15,
                    life: 60 + Math.random() * 30,
                    size: 2 + Math.random() * 3
                });
            }

            // Agregar efecto temporal
            game.collisionEffect = effect;
        }

        // Iniciar secuencia de game over con retardo y fadeout
        function startGameOverSequence() {
            game.gameOverSequence.active = true;
            game.gameOverSequence.timer = 0;
            game.gameOverSequence.fadeAlpha = 0;

            console.log('üé¨ Iniciando secuencia de game over...');
        }

        // Detecci√≥n de colisiones cercanas (para advertencias)
        function checkNearCollisions() {
            const player = game.player;
            const warningDistance = 50;
            let nearObstacles = 0;

            // Verificar obst√°culos del suelo cercanos
            game.obstacles.forEach(obstacle => {
                const distance = Math.abs((obstacle.x + obstacle.width / 2) - (player.x + player.width / 2));
                if (distance < warningDistance &&
                    Math.abs((obstacle.y + obstacle.height / 2) - (player.y + player.height / 2)) < 100) {
                    nearObstacles++;
                }
            });

            // Verificar obst√°culos superiores cercanos
            game.upperObstacles.forEach(obstacle => {
                const distance = Math.abs((obstacle.x + obstacle.width / 2) - (player.x + player.width / 2));
                if (distance < warningDistance &&
                    Math.abs((obstacle.y + obstacle.height / 2) - (player.y + player.height / 2)) < 100) {
                    nearObstacles++;
                }
            });

            return nearObstacles;
        }

        // Test de colisiones (funci√≥n de debug)
        function testCollisionSystem() {
            console.log('üß™ Ejecutando tests de colisiones...');

            // Test 1: Colisi√≥n b√°sica
            const testPlayer = {
                x: 100, y: 100, width: 30, height: 30,
                hitbox: { offsetX: 3, offsetY: 3, width: 24, height: 24 }
            };

            const testObstacle = {
                x: 110, y: 110, width: 20, height: 50,
                hitbox: { offsetX: 2, offsetY: 2, width: 16, height: 46 }
            };

            const collision1 = checkPreciseCollision(testPlayer, testObstacle);
            console.log('Test 1 - Colisi√≥n b√°sica:', collision1 ? '‚úÖ PASS' : '‚ùå FAIL');

            // Test 2: Sin colisi√≥n
            testObstacle.x = 200;
            const collision2 = checkPreciseCollision(testPlayer, testObstacle);
            console.log('Test 2 - Sin colisi√≥n:', !collision2 ? '‚úÖ PASS' : '‚ùå FAIL');

            // Test 3: Colisi√≥n por borde
            testObstacle.x = 124; // Justo en el borde
            const collision3 = checkPreciseCollision(testPlayer, testObstacle);
            console.log('Test 3 - Colisi√≥n por borde:', !collision3 ? '‚úÖ PASS' : '‚ùå FAIL');

            console.log('üß™ Tests de colisiones completados');
        }

        function drawWorldGrid(ctx) {
            const bounds = game.world.bounds;
            const gridSize = 50;

            // Calcular qu√© l√≠neas del grid est√°n visibles
            const visibleLeft = Math.max(bounds.left, game.camera.x - gridSize);
            const visibleRight = Math.min(bounds.right, game.camera.x + game.canvas.width + gridSize);
            const visibleTop = Math.max(bounds.top, game.camera.y - gridSize);
            const visibleBottom = Math.min(bounds.bottom, game.camera.y + game.canvas.height + gridSize);

            // Configurar estilo del grid
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 0.5;
            ctx.globalAlpha = 0.3;

            // L√≠neas verticales
            const startX = Math.floor(visibleLeft / gridSize) * gridSize;
            for (let x = startX; x <= visibleRight; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, visibleTop);
                ctx.lineTo(x, visibleBottom);
                ctx.stroke();
            }

            // L√≠neas horizontales
            const startY = Math.floor(visibleTop / gridSize) * gridSize;
            for (let y = startY; y <= visibleBottom; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(visibleLeft, y);
                ctx.lineTo(visibleRight, y);
                ctx.stroke();
            }

            // Grid especial en el nivel del suelo principal (m√°s visible)
            ctx.strokeStyle = '#555555';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.5;

            const groundY = game.world.surface.groundY;
            if (groundY >= visibleTop && groundY <= visibleBottom) {
                ctx.beginPath();
                ctx.moveTo(visibleLeft, groundY);
                ctx.lineTo(visibleRight, groundY);
                ctx.stroke();
            }

            // Restaurar alpha
            ctx.globalAlpha = 1.0;
        }

        function drawWorldSurfaces(ctx) {
            const surface = game.world.surface;
            const bounds = game.world.bounds;

            // Calcular qu√© parte del mundo est√° visible
            const visibleLeft = Math.max(bounds.left, game.camera.x - 100);
            const visibleRight = Math.min(bounds.right, game.camera.x + game.canvas.width + 100);
            const visibleTop = Math.max(bounds.top, game.camera.y - 100);
            const visibleBottom = Math.min(bounds.bottom, game.camera.y + game.canvas.height + 100);

            ctx.fillStyle = '#404040';

            // Dibujar suelo principal (se extiende por todo el ancho del mundo)
            if (surface.groundY >= visibleTop && surface.groundY <= visibleBottom) {
                ctx.fillRect(
                    visibleLeft,
                    surface.groundY,
                    visibleRight - visibleLeft,
                    surface.thickness
                );
            }

            // Dibujar techo principal (se extiende por todo el ancho del mundo)
            if (surface.ceilingY >= visibleTop && surface.ceilingY + surface.thickness <= visibleBottom) {
                ctx.fillRect(
                    visibleLeft,
                    surface.ceilingY,
                    visibleRight - visibleLeft,
                    surface.thickness
                );
            }

            // Dibujar plataformas adicionales para exploraci√≥n vertical
            drawAdditionalPlatforms(ctx, visibleLeft, visibleRight, visibleTop, visibleBottom);
        }

        function drawAdditionalPlatforms(ctx, visibleLeft, visibleRight, visibleTop, visibleBottom) {
            ctx.fillStyle = '#606060'; // Color ligeramente diferente para plataformas adicionales

            // Plataformas superiores
            const upperPlatforms = [
                { y: -100, width: 200, x: 500 },
                { y: -200, width: 300, x: 1000 },
                { y: -150, width: 150, x: 1800 },
                { y: -300, width: 250, x: 2500 },
                { y: -100, width: 180, x: 3200 },
                { y: -250, width: 220, x: 4000 }
            ];

            // Plataformas inferiores
            const lowerPlatforms = [
                { y: 600, width: 250, x: 800 },
                { y: 700, width: 200, x: 1500 },
                { y: 650, width: 300, x: 2200 },
                { y: 750, width: 180, x: 3000 },
                { y: 680, width: 220, x: 3800 },
                { y: 720, width: 160, x: 4500 }
            ];

            // Dibujar plataformas superiores
            upperPlatforms.forEach(platform => {
                if (platform.x + platform.width >= visibleLeft &&
                    platform.x <= visibleRight &&
                    platform.y >= visibleTop &&
                    platform.y <= visibleBottom) {
                    ctx.fillRect(platform.x, platform.y, platform.width, 20);
                }
            });

            // Dibujar plataformas inferiores
            lowerPlatforms.forEach(platform => {
                if (platform.x + platform.width >= visibleLeft &&
                    platform.x <= visibleRight &&
                    platform.y >= visibleTop &&
                    platform.y <= visibleBottom) {
                    ctx.fillRect(platform.x, platform.y, platform.width, 20);
                }
            });
        }

        function render() {
            const ctx = game.ctx;

            // Limpiar canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);

            // Aplicar transformaci√≥n de c√°mara
            ctx.save();
            ctx.translate(-game.camera.x, -game.camera.y);

            // Dibujar grid mundial que se extiende por todo el mundo
            drawWorldGrid(ctx);

            // Dibujar superficies del mundo (suelo y techo extendidos)
            drawWorldSurfaces(ctx);

            // Dibujar jugador con efecto de peligro
            const dangerLevel = calculateDangerLevel();

            // Color del jugador basado en el peligro
            if (dangerLevel === 0) {
                ctx.fillStyle = '#FFFFFF'; // Blanco normal
            } else if (dangerLevel === 1) {
                ctx.fillStyle = '#F0F0F0'; // Ligeramente m√°s tenue
            } else {
                ctx.fillStyle = '#E0E0E0'; // M√°s tenue (m√°ximo peligro)
            }

            ctx.fillRect(game.player.x, game.player.y, game.player.width, game.player.height);

            // Agregar borde de advertencia si hay peligro
            if (dangerLevel > 0) {
                ctx.strokeStyle = dangerLevel === 1 ? '#C0C0C0' : '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(game.player.x - 1, game.player.y - 1, game.player.width + 2, game.player.height + 2);
            }

            // Dibujar obst√°culos del suelo
            ctx.fillStyle = '#808080';
            game.obstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });

            // Dibujar obst√°culos superiores
            ctx.fillStyle = '#606060'; // Ligeramente m√°s oscuros para diferenciaci√≥n
            game.upperObstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                // Agregar peque√±o detalle visual (l√≠neas de "colgado")
                ctx.strokeStyle = '#404040';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const lineX = obstacle.x + (obstacle.width / 4) * (i + 1);
                    ctx.beginPath();
                    ctx.moveTo(lineX, obstacle.y);
                    ctx.lineTo(lineX, obstacle.y + 10);
                    ctx.stroke();
                }
            });

            // Dibujar monedas
            game.coins.forEach(coin => {
                if (!coin.collected) {
                    // Animaci√≥n de rotaci√≥n
                    const time = Date.now() * 0.005;
                    const scale = 0.8 + Math.sin(time + coin.animationOffset) * 0.2;

                    ctx.save();
                    ctx.translate(coin.x + coin.width / 2, coin.y + coin.height / 2);
                    ctx.scale(scale, scale);

                    // Dibujar moneda dorada
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(0, 0, coin.width / 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Borde m√°s oscuro
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // S√≠mbolo de moneda
                    ctx.fillStyle = '#FF8C00';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('$', 0, 3);

                    ctx.restore();
                }
            });

            // Efectos de dash
            if (!game.player.dashAvailable) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(game.player.x - 5, game.player.y - 5, game.player.width + 10, game.player.height + 10);
            }

            // Renderizar efecto de colisi√≥n
            if (game.collisionEffect) {
                renderCollisionEffect(ctx);
            }

            // Renderizar efecto de cambio de gravedad
            if (game.gravityEffect) {
                renderGravityEffect(ctx);
            }

            // Renderizar efecto de recolecci√≥n de monedas
            if (game.coinEffect) {
                renderCoinEffect(ctx);
            }

            // Renderizar hitboxes de debug (solo si est√° habilitado)
            if (game.config.showHitboxes) {
                renderDebugHitboxes(ctx);
            }

            // Renderizar fadeout de game over
            if (game.gameOverSequence.active && game.gameOverSequence.fadeAlpha > 0) {
                ctx.fillStyle = `rgba(0, 0, 0, ${game.gameOverSequence.fadeAlpha})`;
                ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);
            }

            // Restaurar transformaci√≥n de c√°mara
            ctx.restore();

            // Renderizar minimapa (sin transformaci√≥n de c√°mara)
            renderMinimap();
        }

        function jump() {
            if (game.player.jumpsLeft > 0) {
                const jumpForce = game.player.gravityInverted ? 12 : -12;
                game.player.velY = jumpForce;
                game.player.jumpsLeft--;
                game.player.onGround = false;

                updateHUD();
            }
        }

        function dash() {
            if (game.player.dashAvailable) {
                game.player.velX = game.keys['KeyA'] || game.keys['ArrowLeft'] ? -10 : 10;
                game.player.dashAvailable = false;

                updateHUD();
            }
        }

        function toggleGravity() {
            const wasInverted = game.player.gravityInverted;
            game.player.gravityInverted = !game.player.gravityInverted;

            // Transici√≥n suave de velocidad
            game.player.velY = game.player.velY * -0.3; // Invertir y reducir velocidad

            // Actualizar contador de cambios de gravedad
            game.obstacleCoordinator.gravityChangeCount++;
            game.obstacleCoordinator.lastGravityState = game.player.gravityInverted;

            // Efecto visual de cambio de gravedad
            showGravityChangeEffect();

            // Log para debug
            console.log(`üîÑ Gravedad cambiada: ${wasInverted ? '‚Üë' : '‚Üì'} ‚Üí ${game.player.gravityInverted ? '‚Üë' : '‚Üì'}`);
            console.log(`üìä Cambios de gravedad totales: ${game.obstacleCoordinator.gravityChangeCount}`);

            updateHUD();
        }

        // Efecto visual para cambio de gravedad
        function showGravityChangeEffect() {
            const player = game.player;
            const effect = {
                x: player.x + player.width / 2,
                y: player.y + player.height / 2,
                particles: [],
                duration: 45
            };

            // Crear part√≠culas que se mueven seg√∫n la nueva gravedad
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const speed = 3 + Math.random() * 2;
                effect.particles.push({
                    x: effect.x,
                    y: effect.y,
                    velX: Math.cos(angle) * speed,
                    velY: Math.sin(angle) * speed * (game.player.gravityInverted ? -1 : 1),
                    life: 45,
                    size: 1 + Math.random() * 2
                });
            }

            game.gravityEffect = effect;
        }

        function updateHUD() {
            document.getElementById('distanceDisplay').textContent = Math.floor(game.stats.distance) + 'm';
            document.getElementById('jumpsDisplay').textContent = game.player.jumpsLeft;
            document.getElementById('dashDisplay').textContent = game.player.dashAvailable ? '‚úì' : '‚úó';
            document.getElementById('gravityDisplay').textContent = game.player.gravityInverted ? '‚Üë' : '‚Üì';
            document.getElementById('coinsDisplay').textContent = game.stats.coins;
            document.getElementById('levelDisplay').textContent = game.level.current;
            document.getElementById('progressDisplay').textContent = Math.floor(game.stats.levelProgress) + '%';

            // Mostrar posici√≥n actual del jugador
            const currentPosition = Math.floor(game.player.x * 0.1);
            const maxPosition = Math.floor(game.world.bounds.right * 0.1);
            document.getElementById('positionDisplay').textContent = `${currentPosition}/${maxPosition}m`;

            // Mostrar altura relativa (0 = nivel del suelo principal)
            const groundLevel = game.world.surface.groundY;
            const altitude = Math.floor((groundLevel - game.player.y) * 0.1);
            document.getElementById('altitudeDisplay').textContent = `${altitude}m`;

            // Calcular nivel de peligro basado en obst√°culos cercanos
            const dangerLevel = calculateDangerLevel();
            const dangerElement = document.getElementById('dangerLevel');

            if (dangerLevel === 0) {
                dangerElement.textContent = '‚óè';
                dangerElement.style.color = '#808080'; // Gris
            } else if (dangerLevel === 1) {
                dangerElement.textContent = '‚óè‚óè';
                dangerElement.style.color = '#C0C0C0'; // Gris claro
            } else {
                dangerElement.textContent = '‚óè‚óè‚óè';
                dangerElement.style.color = '#FFFFFF'; // Blanco (m√°ximo peligro)
            }

            // Actualizar indicador de dificultad
            const difficultyLevel = game.obstacleCoordinator.difficultyLevel;
            const difficultyElement = document.getElementById('difficultyLevel');

            if (difficultyLevel < 0.2) {
                difficultyElement.textContent = 'I';
                difficultyElement.style.color = '#808080';
            } else if (difficultyLevel < 0.4) {
                difficultyElement.textContent = 'II';
                difficultyElement.style.color = '#909090';
            } else if (difficultyLevel < 0.6) {
                difficultyElement.textContent = 'III';
                difficultyElement.style.color = '#A0A0A0';
            } else if (difficultyLevel < 0.8) {
                difficultyElement.textContent = 'IV';
                difficultyElement.style.color = '#B0B0B0';
            } else {
                difficultyElement.textContent = 'V';
                difficultyElement.style.color = '#FFFFFF';
            }
        }

        function calculateDangerLevel() {
            // Usar el nuevo sistema de detecci√≥n de colisiones cercanas
            const nearObstacles = checkNearCollisions();

            // Retornar nivel de peligro (0-2)
            return Math.min(nearObstacles, 2);
        }

        function togglePause() {
            game.paused = !game.paused;
            document.getElementById('pauseBtn').textContent = game.paused ? 'REANUDAR' : 'PAUSA';
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function toggleMinimap() {
            const minimapContainer = document.getElementById('minimapContainer');
            game.minimap.visible = !game.minimap.visible;

            if (game.minimap.visible) {
                minimapContainer.classList.remove('hidden');
            } else {
                minimapContainer.classList.add('hidden');
            }
        }

        function renderMinimap() {
            if (!game.minimap.visible) return;

            const minimapCanvas = document.getElementById('minimapCanvas');
            const minimapCtx = minimapCanvas.getContext('2d');

            // Limpiar minimapa
            minimapCtx.fillStyle = '#000000';
            minimapCtx.fillRect(0, 0, game.minimap.width, game.minimap.height);

            // Calcular offsets del minimapa centrados en el jugador
            const playerScreenX = game.player.x * game.minimap.scale;
            const playerScreenY = game.player.y * game.minimap.scale;

            game.minimap.offsetX = Math.max(0, Math.min(
                (game.world.bounds.right * game.minimap.scale) - game.minimap.width,
                playerScreenX - game.minimap.width / 2
            ));

            game.minimap.offsetY = Math.max(0, Math.min(
                (game.world.bounds.bottom * game.minimap.scale) - game.minimap.height,
                playerScreenY - game.minimap.height / 2
            ));

            // Dibujar grid del minimapa
            minimapCtx.strokeStyle = '#222222';
            minimapCtx.lineWidth = 0.5;
            const gridSize = 50 * game.minimap.scale;

            for (let x = -game.minimap.offsetX % gridSize; x < game.minimap.width; x += gridSize) {
                minimapCtx.beginPath();
                minimapCtx.moveTo(x, 0);
                minimapCtx.lineTo(x, game.minimap.height);
                minimapCtx.stroke();
            }

            for (let y = -game.minimap.offsetY % gridSize; y < game.minimap.height; y += gridSize) {
                minimapCtx.beginPath();
                minimapCtx.moveTo(0, y);
                minimapCtx.lineTo(game.minimap.width, y);
                minimapCtx.stroke();
            }

            // Dibujar superficies principales (suelo y techo)
            minimapCtx.fillStyle = '#404040';
            const groundY = (game.world.surface.groundY * game.minimap.scale) - game.minimap.offsetY;
            const ceilingY = (game.world.surface.ceilingY * game.minimap.scale) - game.minimap.offsetY;
            const thickness = game.world.surface.thickness * game.minimap.scale;

            if (groundY >= 0 && groundY <= game.minimap.height) {
                minimapCtx.fillRect(0, groundY, game.minimap.width, thickness);
            }
            if (ceilingY >= 0 && ceilingY <= game.minimap.height) {
                minimapCtx.fillRect(0, ceilingY, game.minimap.width, thickness);
            }

            // Dibujar plataformas adicionales
            minimapCtx.fillStyle = '#606060';
            const platforms = [
                // Plataformas superiores
                { y: -100, width: 200, x: 500 }, { y: -200, width: 300, x: 1000 },
                { y: -150, width: 150, x: 1800 }, { y: -300, width: 250, x: 2500 },
                { y: -100, width: 180, x: 3200 }, { y: -250, width: 220, x: 4000 },
                // Plataformas inferiores
                { y: 600, width: 250, x: 800 }, { y: 700, width: 200, x: 1500 },
                { y: 650, width: 300, x: 2200 }, { y: 750, width: 180, x: 3000 },
                { y: 680, width: 220, x: 3800 }, { y: 720, width: 160, x: 4500 }
            ];

            platforms.forEach(platform => {
                const x = (platform.x * game.minimap.scale) - game.minimap.offsetX;
                const y = (platform.y * game.minimap.scale) - game.minimap.offsetY;
                const width = platform.width * game.minimap.scale;
                const height = 20 * game.minimap.scale;

                if (x + width >= 0 && x <= game.minimap.width &&
                    y + height >= 0 && y <= game.minimap.height) {
                    minimapCtx.fillRect(x, y, width, height);
                }
            });

            // Dibujar obst√°culos
            minimapCtx.fillStyle = '#808080';
            [...game.obstacles, ...game.upperObstacles].forEach(obstacle => {
                const x = (obstacle.x * game.minimap.scale) - game.minimap.offsetX;
                const y = (obstacle.y * game.minimap.scale) - game.minimap.offsetY;
                const width = obstacle.width * game.minimap.scale;
                const height = obstacle.height * game.minimap.scale;

                if (x + width >= 0 && x <= game.minimap.width &&
                    y + height >= 0 && y <= game.minimap.height) {
                    minimapCtx.fillRect(x, y, width, height);
                }
            });

            // Dibujar monedas con diferentes colores seg√∫n su ubicaci√≥n
            game.coins.forEach(coin => {
                if (!coin.collected) {
                    const x = (coin.x * game.minimap.scale) - game.minimap.offsetX;
                    const y = (coin.y * game.minimap.scale) - game.minimap.offsetY;
                    const size = Math.max(2, coin.width * game.minimap.scale);

                    if (x + size >= 0 && x <= game.minimap.width &&
                        y + size >= 0 && y <= game.minimap.height) {

                        // Color seg√∫n la dificultad de acceso
                        if (coin.y < game.world.surface.ceilingY + 100) {
                            minimapCtx.fillStyle = '#00FFFF'; // Cyan para √°reas superiores
                        } else if (coin.y > game.world.surface.groundY - 100) {
                            minimapCtx.fillStyle = '#FF6B6B'; // Rojo para √°reas inferiores
                        } else {
                            minimapCtx.fillStyle = '#FFD700'; // Dorado para √°rea principal
                        }

                        minimapCtx.fillRect(x, y, size, size);
                    }
                }
            });

            // Dibujar jugador con indicador de direcci√≥n
            const playerX = (game.player.x * game.minimap.scale) - game.minimap.offsetX;
            const playerY = (game.player.y * game.minimap.scale) - game.minimap.offsetY;
            const playerSize = Math.max(3, game.player.width * game.minimap.scale);

            // Fondo del jugador
            minimapCtx.fillStyle = '#000000';
            minimapCtx.fillRect(playerX - 1, playerY - 1, playerSize + 2, playerSize + 2);

            // Jugador
            minimapCtx.fillStyle = '#FFFFFF';
            minimapCtx.fillRect(playerX, playerY, playerSize, playerSize);

            // Indicador de gravedad
            minimapCtx.fillStyle = game.player.gravityInverted ? '#FF6B6B' : '#00FF00';
            const indicatorSize = 2;
            const indicatorY = game.player.gravityInverted ? playerY - 3 : playerY + playerSize + 1;
            minimapCtx.fillRect(playerX + playerSize / 2 - indicatorSize / 2, indicatorY, indicatorSize, indicatorSize);

            // Dibujar l√≠mites del mundo
            minimapCtx.strokeStyle = '#666666';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(0, 0, game.minimap.width, game.minimap.height);

            // Indicador de progreso del nivel
            minimapCtx.strokeStyle = '#FFD700';
            minimapCtx.lineWidth = 2;
            const progressWidth = (game.stats.levelProgress / 100) * game.minimap.width;
            minimapCtx.strokeRect(0, game.minimap.height - 3, progressWidth, 3);
        }

        function gameOver() {
            console.log('üéÆ Ejecutando gameOver()');

            // Detener el juego
            game.running = false;

            // Resetear estado de secuencia
            game.gameOverSequence.active = false;
            game.gameOverSequence.timer = 0;
            game.gameOverSequence.fadeAlpha = 0;

            // Mostrar estad√≠sticas de patrones en consola
            console.log('üéÆ Estad√≠sticas de la partida:');
            console.log('Distancia:', Math.floor(game.stats.distance) + 'm');
            console.log('Dificultad final:', (game.obstacleCoordinator.difficultyLevel * 100).toFixed(1) + '%');
            console.log('Cambios de gravedad:', game.obstacleCoordinator.gravityChangeCount);
            console.log('√öltimo patr√≥n:', game.obstacleCoordinator.lastPattern);
            console.log('Historial de patrones:', game.obstacleCoordinator.patternHistory);
            console.log('üé¨ Secuencia de game over completada');

            // Actualizar r√©cords
            const currentDistance = Math.floor(game.stats.distance);
            const bestDistance = parseInt(localStorage.getItem('bestDistance') || '0');

            if (currentDistance > bestDistance) {
                localStorage.setItem('bestDistance', currentDistance.toString());
                document.getElementById('bestDistance').textContent = currentDistance;
            }

            const gamesPlayed = parseInt(localStorage.getItem('gamesPlayed') || '0') + 1;
            localStorage.setItem('gamesPlayed', gamesPlayed.toString());
            document.getElementById('gamesPlayed').textContent = gamesPlayed;

            // Mostrar pantalla de game over con transici√≥n suave
            document.getElementById('finalDistance').textContent = currentDistance;
            showScreen('gameOverScreen');

            console.log('üéÆ gameOver() completado, pantalla mostrada');
        }

        // Balanceador din√°mico de dificultad
        function balanceDifficulty() {
            const coordinator = game.obstacleCoordinator;
            const player = game.player;

            // Ajustar espaciado basado en el rendimiento del jugador
            if (player.jumpsLeft === 0 && !player.onGround) {
                // Jugador en problemas, reducir dificultad ligeramente
                coordinator.minSpacing = Math.min(coordinator.minSpacing + 0.5, 180);
                coordinator.maxSpacing = Math.min(coordinator.maxSpacing + 0.5, 320);
            } else if (player.jumpsLeft === 2 && player.dashAvailable) {
                // Jugador en buena forma, puede aumentar dificultad
                coordinator.minSpacing = Math.max(coordinator.minSpacing - 0.2, 120);
                coordinator.maxSpacing = Math.max(coordinator.maxSpacing - 0.2, 280);
            }

            // Bonus por uso inteligente de gravedad
            if (coordinator.gravityChangeCount > 0) {
                const gravityBonus = Math.min(coordinator.gravityChangeCount * 2, 20);
                coordinator.minSpacing = Math.max(coordinator.minSpacing - gravityBonus * 0.1, 100);
                coordinator.maxSpacing = Math.max(coordinator.maxSpacing - gravityBonus * 0.1, 250);
            }

            // Mantener l√≠mites razonables
            coordinator.minSpacing = Math.max(100, Math.min(180, coordinator.minSpacing));
            coordinator.maxSpacing = Math.max(250, Math.min(350, coordinator.maxSpacing));
        }

        // Renderizar efecto de colisi√≥n mejorado
        function renderCollisionEffect(ctx) {
            const effect = game.collisionEffect;
            if (!effect) return;

            // Actualizar y renderizar part√≠culas
            effect.particles.forEach(particle => {
                // Actualizar posici√≥n
                particle.x += particle.velX;
                particle.y += particle.velY;
                particle.velX *= 0.92; // Fricci√≥n m√°s gradual
                particle.velY *= 0.92;
                particle.life--;

                // Renderizar part√≠cula con tama√±o variable
                if (particle.life > 0) {
                    const alpha = particle.life / 60;
                    const size = particle.size * alpha;

                    // Part√≠culas blancas con glow
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fillRect(particle.x - size / 2, particle.y - size / 2, size, size);

                    // Efecto de glow
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
                    ctx.fillRect(particle.x - size, particle.y - size, size * 2, size * 2);
                }
            });

            // Remover efecto cuando termine
            effect.duration--;
            if (effect.duration <= 0) {
                game.collisionEffect = null;
            }
        }

        // Renderizar efecto de cambio de gravedad
        function renderGravityEffect(ctx) {
            const effect = game.gravityEffect;
            if (!effect) return;

            // Actualizar y renderizar part√≠culas
            effect.particles.forEach(particle => {
                // Actualizar posici√≥n
                particle.x += particle.velX;
                particle.y += particle.velY;
                particle.velX *= 0.98; // Fricci√≥n ligera
                particle.velY *= 0.98;
                particle.life--;

                // Renderizar part√≠cula con color seg√∫n gravedad
                if (particle.life > 0) {
                    const alpha = particle.life / 45;
                    const size = particle.size * alpha;

                    // Color diferente seg√∫n gravedad
                    const color = game.player.gravityInverted ? '200, 200, 255' : '255, 200, 200';

                    ctx.fillStyle = `rgba(${color}, ${alpha})`;
                    ctx.fillRect(particle.x - size / 2, particle.y - size / 2, size, size);
                }
            });

            // Remover efecto cuando termine
            effect.duration--;
            if (effect.duration <= 0) {
                game.gravityEffect = null;
            }
        }

        // Renderizar efecto de recolecci√≥n de monedas
        function renderCoinEffect(ctx) {
            const effect = game.coinEffect;
            if (!effect) return;

            // Actualizar y renderizar part√≠culas doradas
            effect.particles.forEach(particle => {
                // Actualizar posici√≥n
                particle.x += particle.velX;
                particle.y += particle.velY;
                particle.velX *= 0.95;
                particle.velY *= 0.95;
                particle.life--;

                // Renderizar part√≠cula dorada
                if (particle.life > 0) {
                    const alpha = particle.life / 30;
                    const size = particle.size * alpha;

                    // Part√≠culas doradas brillantes
                    ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                    ctx.fillRect(particle.x - size / 2, particle.y - size / 2, size, size);

                    // Efecto de brillo
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                    ctx.fillRect(particle.x - size / 4, particle.y - size / 4, size / 2, size / 2);
                }
            });

            // Remover efecto cuando termine
            effect.duration--;
            if (effect.duration <= 0) {
                game.coinEffect = null;
            }
        }

        // Renderizar hitboxes de debug
        function renderDebugHitboxes(ctx) {
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 1;

            // Hitbox del jugador
            const playerHitbox = {
                x: game.player.x + game.player.hitbox.offsetX,
                y: game.player.y + game.player.hitbox.offsetY,
                width: game.player.hitbox.width,
                height: game.player.hitbox.height
            };
            ctx.strokeRect(playerHitbox.x, playerHitbox.y, playerHitbox.width, playerHitbox.height);

            // Hitboxes de obst√°culos del suelo
            ctx.strokeStyle = '#00FF00';
            game.obstacles.forEach(obstacle => {
                const hitbox = {
                    x: obstacle.x + obstacle.hitbox.offsetX,
                    y: obstacle.y + obstacle.hitbox.offsetY,
                    width: obstacle.hitbox.width,
                    height: obstacle.hitbox.height
                };
                ctx.strokeRect(hitbox.x, hitbox.y, hitbox.width, hitbox.height);
            });

            // Hitboxes de obst√°culos superiores
            ctx.strokeStyle = '#0000FF';
            game.upperObstacles.forEach(obstacle => {
                const hitbox = {
                    x: obstacle.x + obstacle.hitbox.offsetX,
                    y: obstacle.y + obstacle.hitbox.offsetY,
                    width: obstacle.hitbox.width,
                    height: obstacle.hitbox.height
                };
                ctx.strokeRect(hitbox.x, hitbox.y, hitbox.width, hitbox.height);
            });
        }

        // Inicializar cuando el DOM est√© listo
        document.addEventListener('DOMContentLoaded', () => {
            init();

            // Cargar r√©cords
            document.getElementById('bestDistance').textContent = localStorage.getItem('bestDistance') || '0';
            document.getElementById('gamesPlayed').textContent = localStorage.getItem('gamesPlayed') || '0';

            console.log('‚úÖ Spikepulse Noir Edition cargado correctamente');
        });

        console.log('‚úÖ Sistema noir b√°sico aplicado');
    </script>
</body>

</html>