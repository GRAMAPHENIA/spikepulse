/**
 * Renderizador de minimapa para Spikepulse
 * @module MinimapRenderer
 */

export class MinimapRenderer {
    /**
     * Crea una nueva instancia del renderizador de minimapa
     * @param {Object} config - Configuraci√≥n del minimapa
     * @param {EventBus} eventBus - Bus de eventos
     */
    constructor(config, eventBus) {
        this.config = config;
        this.eventBus = eventBus;
        this.isInitialized = false;
        
        // Configuraci√≥n del minimapa
        this.minimapConfig = {
            enabled: config.enabled !== false,
            width: config.width || 200,
            height: config.height || 100,
            position: config.position || 'top-right',
            scale: config.scale || 0.1,
            backgroundColor: config.backgroundColor || 'rgba(0, 0, 0, 0.7)',
            borderColor: config.borderColor || '#FFD700',
            borderWidth: config.borderWidth || 2,
            showPlayer: config.showPlayer !== false,
            showObstacles: config.showObstacles !== false,
            showCollectibles: config.showCollectibles !== false,
            showViewport: config.showViewport !== false,
            opacity: config.opacity || 0.8
        };
        
        // Posici√≥n del minimapa en pantalla
        this.screenPosition = {
            x: 0,
            y: 0
        };
        
        // √Årea del mundo visible en el minimapa
        this.worldBounds = {
            x: 0,
            y: 0,
            width: 2000,
            height: 600
        };
        
        // Viewport de la c√°mara principal
        this.cameraViewport = {
            x: 0,
            y: 0,
            width: 1200,
            height: 600
        };
        
        // Referencias a objetos del juego
        this.gameObjects = {
            player: null,
            obstacles: [],
            collectibles: [],
            world: null
        };
        
        // Canvas interno para el minimapa (opcional)
        this.minimapCanvas = null;
        this.minimapCtx = null;
        
        // Estado de renderizado
        this.needsUpdate = true;
        this.lastUpdateTime = 0;
        this.updateInterval = 100; // Actualizar cada 100ms
        
        console.log('üó∫Ô∏è MinimapRenderer creado');
    }
    
    /**
     * Inicializa el renderizador de minimapa
     */
    async init() {
        try {
            console.log('üîß Inicializando MinimapRenderer...');
            
            // Calcular posici√≥n en pantalla
            this.calculateScreenPosition();
            
            // Crear canvas interno si es necesario
            if (this.minimapConfig.useInternalCanvas) {
                this.createInternalCanvas();
            }
            
            // Configurar event listeners
            this.setupEventListeners();
            
            this.isInitialized = true;
            console.log('‚úÖ MinimapRenderer inicializado');
            
        } catch (error) {
            console.error('‚ùå Error inicializando MinimapRenderer:', error);
            throw error;
        }
    }
    
    /**
     * Calcula la posici√≥n del minimapa en pantalla
     */
    calculateScreenPosition() {
        const margin = 10;\n        \n        switch (this.minimapConfig.position) {\n            case 'top-left':\n                this.screenPosition.x = margin;\n                this.screenPosition.y = margin;\n                break;\n                \n            case 'top-right':\n                this.screenPosition.x = window.innerWidth - this.minimapConfig.width - margin;\n                this.screenPosition.y = margin;\n                break;\n                \n            case 'bottom-left':\n                this.screenPosition.x = margin;\n                this.screenPosition.y = window.innerHeight - this.minimapConfig.height - margin;\n                break;\n                \n            case 'bottom-right':\n                this.screenPosition.x = window.innerWidth - this.minimapConfig.width - margin;\n                this.screenPosition.y = window.innerHeight - this.minimapConfig.height - margin;\n                break;\n                \n            default:\n                // Posici√≥n personalizada\n                this.screenPosition.x = this.minimapConfig.x || margin;\n                this.screenPosition.y = this.minimapConfig.y || margin;\n                break;\n        }\n    }\n    \n    /**\n     * Crea un canvas interno para el minimapa\n     */\n    createInternalCanvas() {\n        this.minimapCanvas = document.createElement('canvas');\n        this.minimapCanvas.width = this.minimapConfig.width;\n        this.minimapCanvas.height = this.minimapConfig.height;\n        this.minimapCtx = this.minimapCanvas.getContext('2d');\n        \n        console.log('üñºÔ∏è Canvas interno del minimapa creado');\n    }\n    \n    /**\n     * Configura event listeners\n     */\n    setupEventListeners() {\n        // Eventos de c√°mara\n        this.eventBus.on('camera:position-changed', this.updateCameraViewport.bind(this));\n        this.eventBus.on('camera:zoom-changed', this.updateCameraViewport.bind(this));\n        \n        // Eventos de objetos del juego\n        this.eventBus.on('player:position-changed', this.updatePlayerPosition.bind(this));\n        this.eventBus.on('world:bounds-changed', this.updateWorldBounds.bind(this));\n        \n        // Eventos de configuraci√≥n\n        this.eventBus.on('minimap:toggle', this.toggle.bind(this));\n        this.eventBus.on('minimap:config-changed', this.updateConfig.bind(this));\n        \n        // Eventos de redimensionado\n        window.addEventListener('resize', this.handleResize.bind(this));\n        \n        console.log('üëÇ Event listeners del minimapa configurados');\n    }\n    \n    /**\n     * Actualiza el renderizador de minimapa\n     * @param {number} deltaTime - Delta time\n     */\n    update(deltaTime) {\n        if (!this.isInitialized || !this.minimapConfig.enabled) return;\n        \n        const currentTime = Date.now();\n        if (currentTime - this.lastUpdateTime < this.updateInterval) {\n            return;\n        }\n        \n        this.lastUpdateTime = currentTime;\n        this.needsUpdate = true;\n    }\n    \n    /**\n     * Renderiza el minimapa\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     * @param {number} deltaTime - Delta time\n     */\n    render(ctx, deltaTime) {\n        if (!this.isInitialized || !this.minimapConfig.enabled) return;\n        \n        ctx.save();\n        \n        // Aplicar opacidad global\n        ctx.globalAlpha = this.minimapConfig.opacity;\n        \n        // Renderizar en canvas interno o directamente\n        if (this.minimapCanvas) {\n            this.renderToInternalCanvas();\n            this.renderInternalCanvasToScreen(ctx);\n        } else {\n            this.renderDirectly(ctx);\n        }\n        \n        ctx.restore();\n    }\n    \n    /**\n     * Renderiza directamente al contexto principal\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     */\n    renderDirectly(ctx) {\n        // Configurar √°rea del minimapa\n        ctx.translate(this.screenPosition.x, this.screenPosition.y);\n        \n        // Renderizar fondo\n        this.renderBackground(ctx);\n        \n        // Configurar clipping\n        ctx.beginPath();\n        ctx.rect(0, 0, this.minimapConfig.width, this.minimapConfig.height);\n        ctx.clip();\n        \n        // Renderizar contenido del mundo\n        this.renderWorldContent(ctx);\n        \n        // Renderizar viewport de la c√°mara\n        if (this.minimapConfig.showViewport) {\n            this.renderCameraViewport(ctx);\n        }\n        \n        // Renderizar borde\n        this.renderBorder(ctx);\n    }\n    \n    /**\n     * Renderiza al canvas interno\n     */\n    renderToInternalCanvas() {\n        if (!this.minimapCtx || !this.needsUpdate) return;\n        \n        // Limpiar canvas\n        this.minimapCtx.clearRect(0, 0, this.minimapConfig.width, this.minimapConfig.height);\n        \n        // Renderizar fondo\n        this.renderBackground(this.minimapCtx);\n        \n        // Configurar clipping\n        this.minimapCtx.beginPath();\n        this.minimapCtx.rect(0, 0, this.minimapConfig.width, this.minimapConfig.height);\n        this.minimapCtx.clip();\n        \n        // Renderizar contenido del mundo\n        this.renderWorldContent(this.minimapCtx);\n        \n        // Renderizar viewport de la c√°mara\n        if (this.minimapConfig.showViewport) {\n            this.renderCameraViewport(this.minimapCtx);\n        }\n        \n        // Renderizar borde\n        this.renderBorder(this.minimapCtx);\n        \n        this.needsUpdate = false;\n    }\n    \n    /**\n     * Renderiza el canvas interno a la pantalla\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     */\n    renderInternalCanvasToScreen(ctx) {\n        if (!this.minimapCanvas) return;\n        \n        ctx.drawImage(\n            this.minimapCanvas,\n            this.screenPosition.x,\n            this.screenPosition.y\n        );\n    }\n    \n    /**\n     * Renderiza el fondo del minimapa\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     */\n    renderBackground(ctx) {\n        ctx.fillStyle = this.minimapConfig.backgroundColor;\n        ctx.fillRect(0, 0, this.minimapConfig.width, this.minimapConfig.height);\n    }\n    \n    /**\n     * Renderiza el contenido del mundo en el minimapa\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     */\n    renderWorldContent(ctx) {\n        ctx.save();\n        \n        // Aplicar transformaci√≥n del mundo al minimapa\n        this.applyWorldTransform(ctx);\n        \n        // Renderizar obst√°culos\n        if (this.minimapConfig.showObstacles) {\n            this.renderObstacles(ctx);\n        }\n        \n        // Renderizar coleccionables\n        if (this.minimapConfig.showCollectibles) {\n            this.renderCollectibles(ctx);\n        }\n        \n        // Renderizar jugador\n        if (this.minimapConfig.showPlayer) {\n            this.renderPlayer(ctx);\n        }\n        \n        ctx.restore();\n    }\n    \n    /**\n     * Aplica la transformaci√≥n del mundo al contexto del minimapa\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     */\n    applyWorldTransform(ctx) {\n        // Calcular escala para que el mundo encaje en el minimapa\n        const scaleX = this.minimapConfig.width / this.worldBounds.width;\n        const scaleY = this.minimapConfig.height / this.worldBounds.height;\n        const scale = Math.min(scaleX, scaleY) * this.minimapConfig.scale;\n        \n        // Centrar el mundo en el minimapa\n        const offsetX = (this.minimapConfig.width - this.worldBounds.width * scale) / 2;\n        const offsetY = (this.minimapConfig.height - this.worldBounds.height * scale) / 2;\n        \n        ctx.translate(offsetX, offsetY);\n        ctx.scale(scale, scale);\n        ctx.translate(-this.worldBounds.x, -this.worldBounds.y);\n    }\n    \n    /**\n     * Renderiza los obst√°culos en el minimapa\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     */\n    renderObstacles(ctx) {\n        ctx.fillStyle = '#FF6B6B'; // Color rojo para obst√°culos\n        \n        for (const obstacle of this.gameObjects.obstacles) {\n            if (this.isObjectInMinimapBounds(obstacle)) {\n                ctx.fillRect(\n                    obstacle.x,\n                    obstacle.y,\n                    obstacle.width || 20,\n                    obstacle.height || 20\n                );\n            }\n        }\n    }\n    \n    /**\n     * Renderiza los coleccionables en el minimapa\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     */\n    renderCollectibles(ctx) {\n        ctx.fillStyle = '#FFD700'; // Color dorado para coleccionables\n        \n        for (const collectible of this.gameObjects.collectibles) {\n            if (this.isObjectInMinimapBounds(collectible)) {\n                ctx.beginPath();\n                ctx.arc(\n                    collectible.x + (collectible.width || 10) / 2,\n                    collectible.y + (collectible.height || 10) / 2,\n                    (collectible.width || 10) / 2,\n                    0,\n                    Math.PI * 2\n                );\n                ctx.fill();\n            }\n        }\n    }\n    \n    /**\n     * Renderiza el jugador en el minimapa\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     */\n    renderPlayer(ctx) {\n        if (!this.gameObjects.player) return;\n        \n        const player = this.gameObjects.player;\n        \n        // Obtener posici√≥n del jugador\n        let playerX = player.x || 0;\n        let playerY = player.y || 0;\n        \n        if (player.getPosition && typeof player.getPosition === 'function') {\n            const pos = player.getPosition();\n            playerX = pos.x;\n            playerY = pos.y;\n        }\n        \n        // Renderizar jugador como punto brillante\n        ctx.fillStyle = '#00FF00'; // Verde brillante\n        ctx.shadowColor = '#00FF00';\n        ctx.shadowBlur = 5;\n        \n        ctx.beginPath();\n        ctx.arc(playerX, playerY, 3, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Resetear shadow\n        ctx.shadowBlur = 0;\n    }\n    \n    /**\n     * Renderiza el viewport de la c√°mara en el minimapa\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     */\n    renderCameraViewport(ctx) {\n        ctx.save();\n        \n        // Resetear transformaci√≥n para dibujar en coordenadas de minimapa\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        \n        // Calcular posici√≥n del viewport en el minimapa\n        const viewportRect = this.worldToMinimapCoords(\n            this.cameraViewport.x,\n            this.cameraViewport.y,\n            this.cameraViewport.width,\n            this.cameraViewport.height\n        );\n        \n        // Renderizar rect√°ngulo del viewport\n        ctx.strokeStyle = '#FFFFFF';\n        ctx.lineWidth = 1;\n        ctx.setLineDash([2, 2]);\n        \n        ctx.strokeRect(\n            this.screenPosition.x + viewportRect.x,\n            this.screenPosition.y + viewportRect.y,\n            viewportRect.width,\n            viewportRect.height\n        );\n        \n        ctx.setLineDash([]);\n        ctx.restore();\n    }\n    \n    /**\n     * Renderiza el borde del minimapa\n     * @param {CanvasRenderingContext2D} ctx - Contexto de canvas\n     */\n    renderBorder(ctx) {\n        ctx.strokeStyle = this.minimapConfig.borderColor;\n        ctx.lineWidth = this.minimapConfig.borderWidth;\n        ctx.strokeRect(0, 0, this.minimapConfig.width, this.minimapConfig.height);\n    }\n    \n    /**\n     * Convierte coordenadas del mundo a coordenadas del minimapa\n     * @param {number} worldX - X del mundo\n     * @param {number} worldY - Y del mundo\n     * @param {number} worldWidth - Ancho del mundo\n     * @param {number} worldHeight - Alto del mundo\n     * @returns {Object} Coordenadas del minimapa\n     */\n    worldToMinimapCoords(worldX, worldY, worldWidth = 0, worldHeight = 0) {\n        const scaleX = this.minimapConfig.width / this.worldBounds.width;\n        const scaleY = this.minimapConfig.height / this.worldBounds.height;\n        const scale = Math.min(scaleX, scaleY) * this.minimapConfig.scale;\n        \n        const offsetX = (this.minimapConfig.width - this.worldBounds.width * scale) / 2;\n        const offsetY = (this.minimapConfig.height - this.worldBounds.height * scale) / 2;\n        \n        return {\n            x: offsetX + (worldX - this.worldBounds.x) * scale,\n            y: offsetY + (worldY - this.worldBounds.y) * scale,\n            width: worldWidth * scale,\n            height: worldHeight * scale\n        };\n    }\n    \n    /**\n     * Verifica si un objeto est√° en los bounds del minimapa\n     * @param {Object} obj - Objeto a verificar\n     * @returns {boolean} True si est√° en bounds\n     */\n    isObjectInMinimapBounds(obj) {\n        if (!obj) return false;\n        \n        const objX = obj.x || 0;\n        const objY = obj.y || 0;\n        const objWidth = obj.width || 0;\n        const objHeight = obj.height || 0;\n        \n        return !(objX + objWidth < this.worldBounds.x ||\n                objX > this.worldBounds.x + this.worldBounds.width ||\n                objY + objHeight < this.worldBounds.y ||\n                objY > this.worldBounds.y + this.worldBounds.height);\n    }\n    \n    // ===== MANEJO DE EVENTOS =====\n    \n    /**\n     * Actualiza el viewport de la c√°mara\n     * @param {Object} data - Datos del viewport\n     */\n    updateCameraViewport(data) {\n        if (data.x !== undefined) this.cameraViewport.x = data.x;\n        if (data.y !== undefined) this.cameraViewport.y = data.y;\n        if (data.width !== undefined) this.cameraViewport.width = data.width;\n        if (data.height !== undefined) this.cameraViewport.height = data.height;\n        \n        this.needsUpdate = true;\n    }\n    \n    /**\n     * Actualiza la posici√≥n del jugador\n     * @param {Object} data - Datos de posici√≥n\n     */\n    updatePlayerPosition(data) {\n        this.needsUpdate = true;\n    }\n    \n    /**\n     * Actualiza los bounds del mundo\n     * @param {Object} data - Datos de bounds\n     */\n    updateWorldBounds(data) {\n        this.worldBounds = { ...data };\n        this.needsUpdate = true;\n    }\n    \n    /**\n     * Alterna la visibilidad del minimapa\n     * @param {Object} data - Datos de toggle\n     */\n    toggle(data) {\n        this.minimapConfig.enabled = data.enabled !== undefined ? data.enabled : !this.minimapConfig.enabled;\n        console.log(`üó∫Ô∏è Minimapa ${this.minimapConfig.enabled ? 'activado' : 'desactivado'}`);\n    }\n    \n    /**\n     * Actualiza la configuraci√≥n del minimapa\n     * @param {Object} data - Nueva configuraci√≥n\n     */\n    updateConfig(data) {\n        this.minimapConfig = { ...this.minimapConfig, ...data };\n        \n        // Recalcular posici√≥n si cambi√≥\n        if (data.position || data.width || data.height) {\n            this.calculateScreenPosition();\n        }\n        \n        this.needsUpdate = true;\n        console.log('‚öôÔ∏è Configuraci√≥n del minimapa actualizada');\n    }\n    \n    /**\n     * Maneja redimensionado de ventana\n     */\n    handleResize() {\n        this.calculateScreenPosition();\n        this.needsUpdate = true;\n    }\n    \n    // ===== M√âTODOS P√öBLICOS =====\n    \n    /**\n     * Establece las referencias a objetos del juego\n     * @param {Object} gameObjects - Objetos del juego\n     */\n    setGameObjects(gameObjects) {\n        this.gameObjects = { ...this.gameObjects, ...gameObjects };\n        this.needsUpdate = true;\n    }\n    \n    /**\n     * Establece la referencia al jugador\n     * @param {Object} player - Referencia al jugador\n     */\n    setPlayer(player) {\n        this.gameObjects.player = player;\n        this.needsUpdate = true;\n    }\n    \n    /**\n     * Establece la lista de obst√°culos\n     * @param {Array} obstacles - Lista de obst√°culos\n     */\n    setObstacles(obstacles) {\n        this.gameObjects.obstacles = obstacles;\n        this.needsUpdate = true;\n    }\n    \n    /**\n     * Establece la lista de coleccionables\n     * @param {Array} collectibles - Lista de coleccionables\n     */\n    setCollectibles(collectibles) {\n        this.gameObjects.collectibles = collectibles;\n        this.needsUpdate = true;\n    }\n    \n    /**\n     * Verifica si un punto est√° dentro del minimapa\n     * @param {number} screenX - X de pantalla\n     * @param {number} screenY - Y de pantalla\n     * @returns {boolean} True si est√° dentro\n     */\n    isPointInMinimap(screenX, screenY) {\n        return screenX >= this.screenPosition.x &&\n               screenX <= this.screenPosition.x + this.minimapConfig.width &&\n               screenY >= this.screenPosition.y &&\n               screenY <= this.screenPosition.y + this.minimapConfig.height;\n    }\n    \n    /**\n     * Convierte coordenadas del minimapa a coordenadas del mundo\n     * @param {number} minimapX - X del minimapa\n     * @param {number} minimapY - Y del minimapa\n     * @returns {Object} Coordenadas del mundo\n     */\n    minimapToWorldCoords(minimapX, minimapY) {\n        const scaleX = this.minimapConfig.width / this.worldBounds.width;\n        const scaleY = this.minimapConfig.height / this.worldBounds.height;\n        const scale = Math.min(scaleX, scaleY) * this.minimapConfig.scale;\n        \n        const offsetX = (this.minimapConfig.width - this.worldBounds.width * scale) / 2;\n        const offsetY = (this.minimapConfig.height - this.worldBounds.height * scale) / 2;\n        \n        const worldX = this.worldBounds.x + (minimapX - offsetX) / scale;\n        const worldY = this.worldBounds.y + (minimapY - offsetY) / scale;\n        \n        return { x: worldX, y: worldY };\n    }\n    \n    /**\n     * Obtiene informaci√≥n de debug\n     * @returns {Object} Informaci√≥n de debug\n     */\n    getDebugInfo() {\n        return {\n            isInitialized: this.isInitialized,\n            config: { ...this.minimapConfig },\n            screenPosition: { ...this.screenPosition },\n            worldBounds: { ...this.worldBounds },\n            cameraViewport: { ...this.cameraViewport },\n            gameObjects: {\n                hasPlayer: this.gameObjects.player !== null,\n                obstacleCount: this.gameObjects.obstacles.length,\n                collectibleCount: this.gameObjects.collectibles.length\n            },\n            needsUpdate: this.needsUpdate,\n            lastUpdateTime: this.lastUpdateTime\n        };\n    }\n    \n    /**\n     * Resetea el renderizador de minimapa\n     */\n    reset() {\n        console.log('üîÑ Reseteando MinimapRenderer...');\n        \n        // Resetear referencias\n        this.gameObjects.player = null;\n        this.gameObjects.obstacles.length = 0;\n        this.gameObjects.collectibles.length = 0;\n        \n        // Resetear viewport\n        this.cameraViewport.x = 0;\n        this.cameraViewport.y = 0;\n        \n        this.needsUpdate = true;\n        \n        console.log('‚úÖ MinimapRenderer reseteado');\n    }\n    \n    /**\n     * Limpia recursos del renderizador de minimapa\n     */\n    destroy() {\n        console.log('üßπ Destruyendo MinimapRenderer...');\n        \n        // Remover event listeners\n        this.eventBus.off('*', this);\n        window.removeEventListener('resize', this.handleResize);\n        \n        // Limpiar canvas interno\n        if (this.minimapCanvas) {\n            this.minimapCanvas = null;\n            this.minimapCtx = null;\n        }\n        \n        // Limpiar referencias\n        this.gameObjects.player = null;\n        this.gameObjects.obstacles.length = 0;\n        this.gameObjects.collectibles.length = 0;\n        \n        this.isInitialized = false;\n        \n        console.log('‚úÖ MinimapRenderer destruido');\n    }\n}